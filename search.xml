<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BASE原则</title>
    <url>/2019/11/03/BASE%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。</p>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble: 基本可用</li>
<li>Soft-state: 软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency: 最终一致性, 也是 ACID 的最终目的</li>
</ul>
<p><img src="/images/2019-11-04T23-58-38.png" alt="acid_base"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>C++命令行参数解析</title>
    <url>/2018/04/14/C++%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>在Linux环境可以使用getopt解析命令行参数.</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>main()函数声明:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main(int argc, char *argv[]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从命令行传递给程序main()函数的包含两个部分的内容, argc 参数包含参数的计数值，而 argv 包含指向这些参数的指针数组.</p>
<span id="more"></span>

<h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>函数getopt位于unistd.h系统头文件中. Windows 没有这个头文件, 所有建议在Linux中使用.</p>
<p>getopt原型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getopt( int argc, char *const argv[], const char *optstring );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>给定了命令参数的数量 (argc)、指向这些参数的数组 (argv) 和选项字符串 (optstring) 后，getopt() 将返回第一个选项，并设置一些全局变量。使用相同的参数再次调用该函数时，它将返回下一个选项，并设置相应的全局变量。如果不再有识别到的选项，将返回 -1，此任务就完成了。</p>
<p>getopt() 所设置的全局变量包括：</p>
<ul>
<li>optarg – 指向当前选项参数（如果有）的指针。</li>
<li>optind – 再次调用 getopt() 时的下一个 argv 指针的索引。</li>
<li>optopt – 最后一个已知选项。</li>
</ul>
<p>对于每个选项，选项字符串 (optstring) 中都包含一个对应的字符。具有参数的选项（如示例中的 -l 和 -o 选项）后面跟有一个 : 字符。示例所使用的 optstring 为 Il:o:vh?（前面提到，还要支持最后两个用于打印程序的使用方法消息的选项）。</p>
<p>可以重复调用 getopt()，直到其返回 -1 为止；任何剩下的命令行参数通常视为文件名或程序相应的其他内容。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;unistd.h&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) &#123;
  std::string file_name;
  int c &#x3D; 0;
  bool s_internal &#x3D; false;
  bool c_internal &#x3D; false;
  while ((c &#x3D; getopt(argc, argv, &quot;scf:h&quot;)) !&#x3D; -1) &#123;
    switch (c) &#123;
      case &#39;c&#39;:
        c_internal &#x3D; true;
        break;
      case &#39;s&#39;:
        s_internal &#x3D; true;
        break;
      case &#39;f&#39;:
        file_name &#x3D; optarg;
        break;
      case &#39;h&#39;:
        break;
      case &#39;:&#39;:   &#x2F;* missing option argument *&#x2F;
        fprintf(stderr, &quot;%s: option &#96;-%c&#39; requires an argument\n&quot;, argv[0], optopt);
        throw &quot;requires an argument&quot;;
      case &#39;?&#39;:
      default:    &#x2F;* invalid option *&#x2F;
        fprintf(stderr, &quot;%s: option &#96;-%c&#39; is invalid: ignored\n&quot;, argv[0], optopt);
        throw &quot;option invalid&quot;;
    &#125;
  &#125;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows可以使用的Boost.Program_options库解析命令行参数.</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;boost&#x2F;program_options.hpp&gt;

int main(int argc, char *argv[]) &#123;
    try &#123;
        namespace po &#x3D; boost::program_options;
        po::options_description desc(&quot;Allowed options&quot;);
        desc.add_options()
            (&quot;xml_to_xls,x&quot;, po::value&lt;std::string&gt;(), &quot;from_xml_to_xls&quot;)
            (&quot;xls_to_xml,s&quot;, po::value&lt;std::string&gt;(), &quot;from_xls_to_xml&quot;)
            (&quot;out,o&quot;, po::value&lt;std::string&gt;(), &quot;assign output file name&quot;);

        po::variables_map vm;
        po::store(parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        std::string out_file;
        if (vm.count(&quot;out&quot;)) &#123;
            out_file &#x3D; vm[&quot;out&quot;].as&lt;std::string&gt;();
        &#125;

        if (vm.count(&quot;xml_to_xls&quot;)) &#123;
            from_xml_to_xls(vm[&quot;xml_to_xls&quot;].as&lt;std::string&gt;(), out_file);
        &#125;
        else if (vm.count(&quot;xls_to_xml&quot;)) &#123;
            from_xls_to_xml(vm[&quot;xls_to_xml&quot;].as&lt;std::string&gt;(), out_file);
        &#125;
        else &#123;
            std::cout &lt;&lt; desc;
        &#125;
    &#125; catch (ModalDefToolException&amp; e) &#123;
        std::cout &lt;&lt; e.what()&lt;&lt;  &quot;\n&quot;;
    &#125; catch (std::logic_error&amp; e) &#123;
        std::cout &lt;&lt; e.what()&lt;&lt;  &quot;\n&quot;;
    &#125; catch (...) &#123;
        std::cout &lt;&lt; &quot;Unkown exception\n&quot;;
    &#125;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>program_options的使用主要通过下面三个组件完成：</p>
<table>
<thead>
<tr>
<th>组件名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>options_description(选项描述器)</td>
<td>描述当前的程序定义了哪些选项</td>
</tr>
<tr>
<td>parse_command_line(选项分析器)</td>
<td>解析由命令行输入的参数</td>
</tr>
<tr>
<td>variables_map(选项存储器)</td>
<td>容器,用于存储解析后的选项</td>
</tr>
</tbody></table>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>构造option_description对象和variables_map对象</li>
<li>add_options(): 向option_description对象添加选项</li>
<li>parse_command_line(): 将命令行输入的参数解析出来</li>
<li>store(): 将解析出的选项存储至variables_map中</li>
<li>notify(): 通知variables_map去更新所有的外部变量</li>
<li>count(): 检测某个选项是否被输入</li>
<li>operator[]: 取出选项的值</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Boost已经提供了编译好的Visual Studio版本, 可以直接<a href="https://dl.bintray.com/boostorg/release/1.65.1/binaries/">下载</a>使用.</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11智能指针</title>
    <url>/2019/11/09/C-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针是使用RAII方法对普通指针进行的封装, 所以智能指针实质是对象, 行为表现是指针.</p>
<p>RAII, Resource Acquisition Is Initialization, 资源获取就是初始化. RAII是一种管理资源、避免泄漏的惯用法. 通常的做法是对于一个对象而言, 我们在构造函数的时候申请空间, 而在析构函数(在离开作用域时调用)的时候释放空间.</p>
<p>使用智能指针可以方便的管理堆内存, 避免使用普通指针容易导致的堆内存未释放或二次释放等问题.</p>
<p>C++智能指针在C++11前是<code>std::auto_ptr</code>, C++11后是<code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>, 使用它们需要包含头文件<code>&lt;memory&gt;</code>.</p>
<span id="more"></span>

<h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a><code>std::auto_ptr</code></h2><p><code>std::auto_ptr</code>是C++11前提供的智能指针, 但从C++11开始, <code>std::auto_ptr</code>开始被弃用, 被<code>std::unique_ptr</code>替代.</p>
<p><code>std::auto_ptr</code>的问题在于允许隐式的所有权转让, 容易导致不易发现的各种错误, 比如空指针访问.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::auto_ptr&lt;std::string&gt; ps1(new std::string(&quot;hello world&quot;));
std::auto_ptr&lt;std::string&gt; ps2;
ps2 &#x3D; ps1;
std::cout &lt;&lt; ps1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>ps2 = ps1</code>后<code>ps1</code>的资源所有权已经释放, 不再指向任何内容, 后面再访问<code>ps1</code>相当于在访问一个空指针.</p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h2><p><code>std::uniqur_ptr</code>在<code>std::auto_ptr</code>的基础上禁止了拷贝和赋值, 这样上述<code>std::auto_ptr</code>中的问题就不存在了, 因为在编译阶段就会报错.</p>
<p>另外, 容器不支持保存<code>std::auto_ptr</code>, 但可以支持保存<code>std::uniqur_ptr</code>.</p>
<p><code>std::uniqur_ptr</code>是应该优先选用的智能指针.</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code>使用引用计数, 多个指针对象可以指向相同的内存. 每次<code>std::shared_ptr</code>的拷贝, 内部引用计数加1; 每次<code>std::shared_ptr</code>的析构, 内部引用计数减1; 当引用计数减为0时, 自动释放指向的内存. <code>std::shared_ptr</code>内部引用计数是线程安全的, 但指向内存不是, 所以多线程使用<code>std::shared_ptr</code>还是需要锁.</p>
<ul>
<li>注意不要使用同一个原始指针初始化多个<code>std::shared_ptr</code>, 否则会造成同一内存的二次释放</li>
<li>注意避免循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏. 这是<code>std::shared_ptr</code>的最大的陷阱.</li>
<li>另外, <code>std::shared_ptr</code>使用的引用计数是增加了内存消耗和复杂性的, 所以能用<code>std::unique_ptr</code>时建议不要使用<code>std::shared_ptr</code>.</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Pimpl技术</title>
    <url>/2022/01/16/C-Pimpl%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="什么是Pimpl技术"><a href="#什么是Pimpl技术" class="headerlink" title="什么是Pimpl技术"></a>什么是Pimpl技术</h2><p>Pimpl，Pointer to Implementation，意为“具体实现的指针”，有着“编译防火墙(compilation firewall)”的名头。</p>
<p>它通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏，降低耦合性和分离接口实现的一个现代 C++ 技术。</p>
<span id="more"></span>
<h2 id="Pimpl代码示例"><a href="#Pimpl代码示例" class="headerlink" title="Pimpl代码示例"></a>Pimpl代码示例</h2><p>View类定义：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>

<span class="token keyword">class</span> <span class="token class-name">View</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">View</span><span class="token punctuation">(</span>View<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    View<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>View<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pimpl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>View类实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"view.h"</span></span>

<span class="token comment">//View::Impl的定义，体现了View类的具体实现细节</span>
<span class="token keyword">class</span> <span class="token class-name">View</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Impl</span></span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

View<span class="token double-colon punctuation">::</span><span class="token class-name">Impl</span><span class="token double-colon punctuation">::</span><span class="token function">Impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    name <span class="token operator">=</span> <span class="token string">"ViewImpl"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> View<span class="token double-colon punctuation">::</span><span class="token class-name">Impl</span><span class="token double-colon punctuation">::</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this is my name:"</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//View类接口的实现</span>
<span class="token class-name">View</span><span class="token double-colon punctuation">::</span><span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pimpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">View</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token class-name">View</span><span class="token double-colon punctuation">::</span><span class="token function">View</span><span class="token punctuation">(</span>View<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
View<span class="token operator">&amp;</span> View<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>View<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">View</span><span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    pimpl<span class="token operator">-></span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>View使用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"view.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello C++ World\n"</span><span class="token punctuation">;</span>

    View v <span class="token operator">=</span> <span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cpp view.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out
Hello C++ World
this is my name:ViewImpl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="Pimpl技术优缺点"><a href="#Pimpl技术优缺点" class="headerlink" title="Pimpl技术优缺点"></a>Pimpl技术优缺点</h2><p>优点：</p>
<ul>
<li>最大程度地减少编译依赖项：其一减少原类不必要的头文件的依赖，加速编译；其二对Impl类进行修改，无需重新编译原类；</li>
<li>接口和实现分离，降低模块的耦合：私有成员隐藏在公有接口之外，给用户一个简洁明了的使用接口， 适合闭源API设计；</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要占用额外的指针内存；</li>
<li>访问时多一次间接指针操作的开销；</li>
<li>在使用、阅读和调试上都可能有所不便；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/KillerAery/p/9539705.html">C++ 编译期封装-Pimpl技术</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/pimpl-for-compile-time-encapsulation-modern-cpp?view=msvc-170">用于编译时封装的 Pimpl（现代 C++）</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>pimpl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态</title>
    <url>/2022/02/04/C-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h2><p>面向对象的三大特性：封装、继承、多态。</p>
<ul>
<li>封装：隐藏对象的属性和实现细节，仅对外公开访问方法，并且控制访问级别在面向对象方法中。简言之，用类实现封装，用封装来实现高内聚，低耦合。</li>
<li>继承：从已有的类中派生出新的类，新的类能吸收已有类的属性和行为， 可以实现重用代码和扩展新的能力。</li>
<li>多态：指通过基类的指针或者引用， <strong>在运行时动态调用实际绑定对象函数的行为</strong>。多态可以简单地概括为“一个接口，多种方法”，它消除类型之间的耦合关系。</li>
</ul>
<p>从一定角度来看，封装和继承几乎都是为多态而准备的。甚至可以说，<strong>多态是设计模式的实现基础。</strong></p>
<span id="more"></span>
<h2 id="多态的条件"><a href="#多态的条件" class="headerlink" title="多态的条件"></a>多态的条件</h2><p>多态的期望行为是<strong>根据实际的对象类型来判断如何调用重写的虚函数</strong>：</p>
<ul>
<li><strong>即当父类指针或引用指向 父类对象时，就调用父类中定义的虚函数</strong>；</li>
<li><strong>即当父类指针或引用指向 子类对象时，就调用子类中定义的虚函数</strong>；</li>
</ul>
<p>即<strong>同样的调用语句在实际运行时有多种不同的表现形态。</strong>根据多态的这种表现效果，C++中实现多态的条件是：</p>
<ol>
<li>继承的存在；继承是多态的基础，没有继承就没有多态。</li>
<li>子类重写父类的虚方法；多态下调用子类重写的虚方法。</li>
<li>父类指针或引用变量指向子类对象；子类到父类的类型转换。</li>
</ol>
<h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><p>C++支持两种多态性：</p>
<ul>
<li>编译时多态性（静态多态）；通过重载函数实现，也叫先期联编 early binding</li>
<li>运行时多态性（动态多态）；通过虚函数实现，也叫滞后联编 late binding</li>
</ul>
<p>多态执行的大致过程如下：</p>
<ol>
<li><p>在类中，用 virtual 声明一个函数时，就会在这个类中对应产生一张 虚函数表，将虚函数存放到该表中；</p>
</li>
<li><p>用这个类创建对象时，就会产生一个 vptr指针，这个vptr指针会指向对应的虚函数表；</p>
</li>
<li><p>在多态调用时, vptr指针 就会根据这个对象 在对应类的虚函数表中 查找被调用的函数，从而找到函数的入口地址；</p>
<ul>
<li>如果这个对象是 子类的对象，那么vptr指针就会在 子类的 虚函数表中查找被调用的函数</li>
<li>如果这个对象是 父类的对象，那么vptr指针就会在 父类的 虚函数表中查找被调用的函数</li>
</ul>
</li>
</ol>
<p><img src="/images/20220204T005410.067.png" alt="image.png"></p>
<p><img src="/images/20220204T005855.002.png" alt="image.png"></p>
<p><img src="/images/20220204T010218.310.png" alt="image.png"></p>
<p><img src="/images/20220204T010241.334.png" alt="image.png"></p>
<p>由于虚函数的存在，在实例化类对象时，就会产生1个 vptr指针。这样，在普通的类中，类的大小 == 成员变量的大小；在有虚函数的类中，类的大小 == 成员变量的大小 + vptr指针大小。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Demo1
&#123;
private:
    int mi; &#x2F;&#x2F; 4 bytes
    int mj; &#x2F;&#x2F; 4 bytes
public:
    virtual void print()&#123;&#125;
&#125;;

class Demo2
&#123;
private:
    int mi; &#x2F;&#x2F; 4 bytes
    int mj; &#x2F;&#x2F; 4 bytes
public:
    void print()&#123;&#125;
&#125;;

int main()
&#123;
    cout &lt;&lt; &quot;sizeof(Demo1) &#x3D; &quot; &lt;&lt; sizeof(Demo1) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; &#x2F;&#x2F; sizeof(Demo1) &#x3D; 16 bytes
    cout &lt;&lt; &quot;sizeof(Demo2) &#x3D; &quot; &lt;&lt; sizeof(Demo2) &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; &#x2F;&#x2F; sizeof(Demo2) &#x3D; 8 bytes
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于虚函数，需要注意以下几点：</p>
<ol>
<li>只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</li>
<li>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</li>
<li>内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。</li>
<li>构造函数不能是虚函数。因为在构造函数执行结束后，虚函数表指针才会被正确的初始化。</li>
<li>析构函数可以是虚函数，而且建议声明为虚函数。因为析构函数是在对象销毁之前被调用，即<strong>在对象销毁前</strong>虚函数表指针是正确指向对应的虚函数表。</li>
<li>构造函数中可以调用虚函数，但是不可能发生多态行为，因为在构造函数执行时，虚函数表指针未被正确初始化。</li>
<li>析构函数中可以调用虚函数，但是不可能发生多态行为，因为<strong>在析构函数执行时</strong>，虚函数表指针已经被销毁。</li>
</ol>
<p>另外，需要注意的是，如果是父类的对象指向子类，则不会发生多态行为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;

class Base &#123;
public:
    virtual int add(int value) &#123;
        std::cout &lt;&lt; &quot;Base add value: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        return 0;
    &#125;
&#125;;

class Driver : public Base &#123;
public:
    int add(int value) override &#123;
        std::cout &lt;&lt; &quot;Driver add value: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        return 0;
    &#125;
&#125;;

int main(int argc, char* argv[]) &#123;
    Base b1 &#x3D; Driver();
    b1.add(22); &#x2F;&#x2F; output: Base add value: 22

    Base* b2 &#x3D; new Driver();
    b2-&gt;add(22); &#x2F;&#x2F; output: Driver add value: 22
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="重写-vs-重载-vs-隐藏"><a href="#重写-vs-重载-vs-隐藏" class="headerlink" title="重写 vs 重载 vs 隐藏"></a>重写 vs 重载 vs 隐藏</h2><p>重写：派生类中存在与基类相同的函数（包括函数名、参数列表和参数个数都相同），包括重写成员函数和重写虚函数；其中重写虚函数才能体现C++的多态性。</p>
<p>重载：在同一个类中，允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。</p>
<p>隐藏：指派生类的函数屏蔽了与其同名的基类函数，隐藏规则如下：</p>
<ul>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/nbk-zyc/p/12274178.html">C++中的多态机制</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37340242">C++ 多态</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++简单log</title>
    <url>/2020/10/11/C-%E7%AE%80%E5%8D%95log/</url>
    <content><![CDATA[<p>平常写一些简单验证程序时，需要频繁输出日志信息便于调试。为了后续验证程序中输出日志信息方便，将平时使用的日志信息抽象成了INFO和FUNC。</p>
<ul>
<li>INFO输出单行日志信息，可以输出当前的时间（格式：%Y-%m-%d %H:%M:%S）、进程号和线程号。</li>
<li>FUNC利用RAII可以在生命周期（比如函数）的开始和结束分别打印日志信息，并统计执行耗时（单位微妙）<span id="more"></span></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;ctime&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#define INFO(msg) \
do &#123; \
    auto now &#x3D; std::chrono::system_clock::now(); \
    auto t &#x3D; std::chrono::system_clock::to_time_t(now); \
    auto fmt_t &#x3D; std::put_time(std::localtime(&amp;t), &quot;%Y-%m-%d %H:%M:%S&quot;); \
    std::ostringstream oss; \
    oss &lt;&lt; fmt_t &lt;&lt; &quot; [&quot; &lt;&lt; getpid() &lt;&lt; &quot;|&quot; &lt;&lt; gettid() &lt;&lt; &quot;] &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;; \
    std::cout &lt;&lt; oss.str(); \
&#125; while (0)

class _UniInfo &#123;
public:
    _UniInfo(const std::string&amp; msg) : msg_(msg) &#123;
        start_ &#x3D; std::chrono::system_clock::now();
        INFO(msg_ &lt;&lt; &quot; Enter&quot;);
    &#125;

    ~_UniInfo() &#123;
        INFO(msg_ &lt;&lt; &quot; Exit&quot;);
        auto end &#x3D; std::chrono::system_clock::now();
        auto elapsed &#x3D; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start_).count();
        INFO(msg_ &lt;&lt; &quot; elapsed time: &quot; &lt;&lt; elapsed &lt;&lt; &quot; microseconds&quot;);
    &#125;
private:
    std::string msg_;
    std::chrono::system_clock::time_point start_;
&#125;;

#define FUNC(msg) \
    std::ostringstream _oss; \
    _oss &lt;&lt; msg; \
    _UniInfo _uniInfo(_oss.str());


#define FUNCTION() FUNC(__func__)

int main(int argc, char* argv[]) &#123;
    FUNCTION();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>INFO中之所以先ostringstream再cout，是由于msg中有可能会存在函数调用，是函数调用先执行后再cout。</p>
</blockquote>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>loging</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型转换</title>
    <url>/2019/12/01/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>当运算符的操作数具有不同的数据类型时, C++会自动将它们按照一定的规则转换为相同的数据类型. 理解这些规则将有助于程序员防止一些细微的错误蔓延到自己的程序中.</p>
<h2 id="基本数据类型隐式转换"><a href="#基本数据类型隐式转换" class="headerlink" title="基本数据类型隐式转换"></a>基本数据类型隐式转换</h2><p>简言之, 基本数据类型的隐式转换遵循的规则是基本数据类型的等级.</p>
<span id="more"></span>

<p>从高到低的基本数据类型的等级排序如下:</p>
<table>
<thead>
<tr>
<th align="left">基本数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">long double</td>
</tr>
<tr>
<td align="left">double</td>
</tr>
<tr>
<td align="left">float</td>
</tr>
<tr>
<td align="left">unsigned long long int</td>
</tr>
<tr>
<td align="left">long long int</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
</tr>
<tr>
<td align="left">long int</td>
</tr>
<tr>
<td align="left">unsigned int</td>
</tr>
<tr>
<td align="left">int</td>
</tr>
</tbody></table>
<p>从上表可以看出, 数据类型越宽等级越高. 所以上述等级排序存在一个例外: 当 int 和 long int 的大小相同时, 在这种情况下, unsigned int 将超越 long int, 因为它可以保存更高的值.</p>
<p>具体规则:</p>
<ul>
<li>char, short 和 unsigned short 值自动升级为 int 值. 即无论何时在数学表达式中使用这些数据类型的值, 它们都将自动升级为 int 类型. 这也是为什么这几个类型不在上述等级排序中.</li>
<li>当运算符使用不同数据类型的两个值时, 较低排名的值将被升级为较高排名值的类型.</li>
<li>当表达式的最终值分配给变量时, 它将被转换为该变量的数据类型.</li>
</ul>
<p>需要注意的是, 隐式转换不仅有升级(一种数据类型被转换为更髙的数据类型), 也有降级(一种数据类型被转换为更低的数据类型). 比如:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double y &#x3D; 3.14;
&#x2F;&#x2F; x被赋值为3，y仍然保留3.14
int x &#x3D; y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>数据类型的转换应该是尽量被避免的. 但如果避无可避, 应该使用显示类型转换, 也就是强制类型转换.</p>
<p>强制类型转换有 C 风格和 C++ 风格.</p>
<p>C 风格强制类型转换形如:</p>
<blockquote>
<p>(type)expression</p>
</blockquote>
<p>C 风格强制类型转换存在下面两个两个方面的不足, 是不推荐的使用的.</p>
<ul>
<li>可以在任意类型之间转换, 但不区分转换类型之间的差异. 比如将指向 const 对象的指针转换成指向非 const 对象的指针, 或者将指向基类对象的指针转换成指向派生类对象的指针.</li>
<li>不易查找. 比如在存量代码中改变转换的类型, 无法快速找出已存在的类型转换.</li>
</ul>
<p>而 C++ 风格的强制类型转换可以弥补 C 风格的不足.</p>
<p>C++ 提供了下面四种类型转换.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>转换数据类型, 类的上下行转换</td>
</tr>
<tr>
<td>const_cast</td>
<td>去除指针或引用的const属性</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>子类和父类之间的多态类型转换</td>
</tr>
<tr>
<td>reinterpreter_cast</td>
<td>重新解释类型转换</td>
</tr>
</tbody></table>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><ul>
<li>转换数据类型, 由于没有运行时类型检查来保证转换的安全性, 不安全</li>
<li>类的上下行转换, 由于没有运行时类型检查, 下行转换不安全</li>
<li>static_cast不能转换掉原有类型的const, volatile, 或者 __unaligned 属性</li>
</ul>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><ul>
<li>转化常量指针为非常量的指针, 并且仍然指向原来的对象</li>
<li>转化常量引用为非常量的引用, 并且仍然指向原来的对象</li>
<li>const_cast 一般用于修改指针, 如 const int *ptr 形式</li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>安全的上行转换(子类到基类的转换)和下行转换(基类到子类的转换).</p>
<p>dynami_cast 在程序运行时对类型转换的”运行期类型信息”(Runtime type information, RTTI)进行了检查，是使用安全的: 转换成功则返回的是指向类的指针或引用，转换失败则返回NULL.</p>
<h3 id="reinterpreter-cast"><a href="#reinterpreter-cast" class="headerlink" title="reinterpreter_cast"></a>reinterpreter_cast</h3><p>行无关类型的转换. 用在任意的指针间的转换, 任意引用间的转换, 指针和足够大的整型之间的转换, 整型到指针的转换.</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask使用https</title>
    <url>/2019/10/04/Flask%E4%BD%BF%E7%94%A8https/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Flask在run时可以通过参数ssl_context指定证书来使得运行的web app使用较为安全的协议https.</p>
<h2 id="安装pyOpenSSL"><a href="#安装pyOpenSSL" class="headerlink" title="安装pyOpenSSL"></a>安装pyOpenSSL</h2><p>pyOpenSSL使Python的openssl库.<br>通过pip安装:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pyOpenSSL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<span id="more"></span>
<h2 id="默认证书"><a href="#默认证书" class="headerlink" title="默认证书"></a>默认证书</h2><p>pyOpenSSL安装完成后就可以使用默认证书将Flask切换为https.</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">5000</span><span class="token punctuation">,</span> ssl_context<span class="token operator">=</span><span class="token string">'adhoc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>ssl_context</strong>参数指明使用的证书, <strong>adhoc</strong>是默认证书, 是pyOpenSSL自带的.</p>
<h2 id="自定义证书"><a href="#自定义证书" class="headerlink" title="自定义证书"></a>自定义证书</h2><h3 id="Generate-a-private-key"><a href="#Generate-a-private-key" class="headerlink" title="Generate a private key"></a>Generate a private key</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa <span class="token parameter variable">-des3</span> <span class="token parameter variable">-out</span> server.key <span class="token number">1024</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Generate-a-CSR"><a href="#Generate-a-CSR" class="headerlink" title="Generate a CSR"></a>Generate a CSR</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> server.key <span class="token parameter variable">-out</span> server.csr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Remove-Passphrase-from-key"><a href="#Remove-Passphrase-from-key" class="headerlink" title="Remove Passphrase from key"></a>Remove Passphrase from key</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> server.key server.key.org
openssl rsa <span class="token parameter variable">-in</span> server.key.org <span class="token parameter variable">-out</span> server.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Generate-self-signed-certificate"><a href="#Generate-self-signed-certificate" class="headerlink" title="Generate self signed certificate"></a>Generate self signed certificate</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-in</span> server.csr <span class="token parameter variable">-signkey</span> server.key <span class="token parameter variable">-out</span> server.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>days</strong>是指证书有效时间, <strong>-days 3650</strong>即证书有效期是3650天.</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>
app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">5000</span><span class="token punctuation">,</span> ssl_context<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'server.crt'</span><span class="token punctuation">,</span> <span class="token string">'server.key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>ssl_context</strong>中配置的crt和key文件使用绝对路径或相对路径.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客添加图片</title>
    <url>/2019/11/08/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p>
</blockquote>
<p>对于在 Hexo 博客中添加图片,  按照 <a href="https://hexo.io/zh-cn/docs/">Hexo文档</a> 推荐的方法, 操作大致如下:</p>
<ul>
<li>设置站点配置<code>_config.yml</code>: 将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code>.</li>
<li>安装插件: <code>npm install hexo-asset-image --save</code>.</li>
<li>生成博客: 运行<code>hexo n &quot;your-title&quot;</code>, 生成<code>your-title.md</code>博文时就会在<code>/source/_posts</code>目录下生成<code>your-title</code>的文件夹, 将你想在<code>your-title</code>博文中插入的照片放置到这个同名文件夹中即可, 图片的命名随意.</li>
<li>添加图片: 在需要添加图片的位置写入图片的链接地址: <code>![your-image-desc](your-image-name.your-image-format)</code>.</li>
</ul>
<span id="more"></span>

<p>另外一种图片存放路径是<code>source/images</code>. 但此时访问图片的方式是<code>![your-image-desc](/images/your-image-name.your-image-format)</code></p>
<p>但如果这样, 当需要在博文中插入一张截图时, 还需要先将截图保存为此目录下的文件, 再在博文中手工添加图片的链接地址.</p>
<p>有没有更快捷的方法?</p>
<p>答案是<strong>有</strong>: 在截图工具将截图复制到剪切板后, 在博文中粘贴一下, 图片文件自动生成, 图片链接地址也自动生成.</p>
<p>如果 Hexo 博文是在<code>VS Code</code>中完成的, 通过对<code>Paste Image</code>扩展进行一定的配置就可以实现图片的方便插入.</p>
<blockquote>
<p>安装<code>Paste Image</code>在<code>VS Code</code>的应用商店中搜索安装即可. 另外 Linux 环境可能会提示安装<code>xclip</code>, 比如<code>sudo aptitude install xclip</code>.</p>
</blockquote>
<ul>
<li><p>配置基本路径. 图片的链接路径中不体现的路径信息. 比如 VS Code 打开是 Hexo 的工程, 图片是存在<code>source/images</code>中, 则配置<code>$&#123;projectRoot&#125;/source</code>.<br><img src="/images/20191109T004150.933.png" alt="base-path"></p>
</li>
<li><p>配置图片文件名格式. 名称是由时间组成的, 但格式可自定义.<br><img src="/images/20191109T005128.154.png" alt="file-name"></p>
</li>
<li><p>配置图片保存路径.<br><img src="/images/20191109T005753.953.png" alt="paste-path"></p>
</li>
<li><p>配置图片链接前缀. 如果图片保存在<code>source/images</code>中, 图片链接路径最前面需要<code>/</code>.<br><img src="/images/20191109T005926.235.png" alt="paste-prefix"></p>
</li>
</ul>
<p>按照上述配置以后, 截图保存到剪贴板后, 直接在博文中<code>Ctrl+Alt+V</code>(不同系统快捷键可能存在差异), 图片就自动保存到指定路径, 博文中自动生成了图片的访问地址.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客</title>
    <url>/2018/05/13/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装Git. 将本地的网页和文章等内容发布或提交到GitHub上需要用到Git.</li>
<li>安装Node.js. Hexo是基于Node.js的高效静态站点生成框架.</li>
<li>安装Hexo. 在Node.js安装完成后, 通过控制台执行以下命令即可.</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-cli <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<span id="more"></span>

<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init leiz2192.hexo
<span class="token builtin class-name">cd</span> leiz2192.hexo
hexo new <span class="token string">"YourBlogTitle"</span> //会生成source/_posts/YourBlogTitle.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后撰写YourBlogTitle.md.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g   //生成网页
hexo s   //s是server的缩写，启动服务, 通过http://localhost:4000/本地访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="创建部署仓库"><a href="#创建部署仓库" class="headerlink" title="创建部署仓库"></a>创建部署仓库</h3><p>在GitHub上”Create a new repository”, Repository name为<em><strong>your-github-user-name</strong></em>.github.io, 比如<em><strong>leiz2192</strong></em>.github.io</p>
<h3 id="配置部署参数"><a href="#配置部署参数" class="headerlink" title="配置部署参数"></a>配置部署参数</h3><p>在_config.yml中配置deploy.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> git
  <span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>leiz2192/leiz2192.github.io.git
  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>repo建议使用ssh方式地址, https方式在部署时会需要输入用户名和密码.</p>
<h3 id="生成发布博客"><a href="#生成发布博客" class="headerlink" title="生成发布博客"></a>生成发布博客</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d <span class="token parameter variable">-g</span>  //生成网页并发布到GitHub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后就可以访问<a href="https://leiz2192.github.io/">博客</a>.</p>
<h2 id="维护博客"><a href="#维护博客" class="headerlink" title="维护博客"></a>维护博客</h2><p>博客的网页在repo <em>leiz2192.github.io</em>中维护, 而博客的md文件可以在repo <em>leiz2192.hexo</em>中维护. 这样数据和网页分离, 便于管理.</p>
<p>而在电脑或系统改变了, git clone <em>leiz2192.hexo</em>后就可以继续维护博客, 而且历史文章不丢失.</p>
<p>另外, 利用git hook可以在每次git push时自动发布博客, 只需在.git/hooks目录中新增pre-push文件, 文件内容如下.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>

hexo d <span class="token parameter variable">-g</span>

<span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="修饰博客"><a href="#修饰博客" class="headerlink" title="修饰博客"></a>修饰博客</h2><h3 id="about"><a href="#about" class="headerlink" title="about"></a>about</h3><p>新建about page</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>修改theme的<code>_config.yml</code>, 去注释<code>menu</code>中的<code>about</code>.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span><span class="token punctuation">...</span>
  <span class="token key atrule">about</span><span class="token punctuation">:</span> /about/ <span class="token punctuation">|</span><span class="token punctuation">|</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后修改<code>source/about/index.md</code>文件即可.</p>
<h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><p>新建tags page</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>修改theme的<code>_config.yml</code>, 去注释<code>menu</code>中的<code>tags</code>.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span><span class="token punctuation">...</span>
  <span class="token key atrule">tags</span><span class="token punctuation">:</span> /tags/ <span class="token punctuation">|</span><span class="token punctuation">|</span> tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后修改<code>source/tags/index.md</code>文件, 增加<code>type: &quot;tags&quot;</code></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span>
<span class="token key atrule">title</span><span class="token punctuation">:</span> tags
<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-04 23:11:52</span>
<span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span>
<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h3><p>新建categories page</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>修改theme的<code>_config.yml</code>, 去注释<code>menu</code>中的<code>categories</code>.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span><span class="token punctuation">...</span>
  <span class="token key atrule">categories</span><span class="token punctuation">:</span> /categories/ <span class="token punctuation">|</span><span class="token punctuation">|</span> th<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后修改<code>source/categories/index.md</code>文件, 增加<code>type: &quot;categories&quot;</code></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span>
<span class="token key atrule">title</span><span class="token punctuation">:</span> categories
<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-04 23:15:38</span>
<span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span>
<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>安装插件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-searchdb <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>修改站点的配置文件<code>_config.yml</code>, 增加以下内容.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>
  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml
  <span class="token key atrule">field</span><span class="token punctuation">:</span> post
  <span class="token key atrule">format</span><span class="token punctuation">:</span> html
  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改theme的<code>_config.yml</code>, 修改<code>local_search</code>的<code>enable</code>为<strong>true</strong>.</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">local_search</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>清理缓存后发布.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean
hexo d <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 32 or 64</title>
    <url>/2018/05/13/Linux-32-or-64/</url>
    <content><![CDATA[<p>查看linux是32位还是64位方法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span>  ~ getconf LONG_BIT
<span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> <span class="token variable"><span class="token variable">$(</span>where <span class="token function">file</span><span class="token variable">)</span></span>
/usr/bin/file: ELF <span class="token number">32</span>-bit LSB executable, Intel <span class="token number">80386</span>, version <span class="token number">1</span> <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, dynamically linked, interpreter /lib/ld-linux.so.2, <span class="token keyword">for</span> GNU/Linux <span class="token number">2.6</span>.32, BuildID<span class="token punctuation">[</span>sha1<span class="token punctuation">]</span><span class="token operator">=</span>a25ff8d819e9d276b6c282d51a572ad74078da3d, stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uname</span> <span class="token parameter variable">-a</span>
Linux ubuntu-xenial <span class="token number">4.4</span>.0-112-generic <span class="token comment">#135-Ubuntu SMP Fri Jan 19 11:48:14 UTC 2018 i686 i686 i686 GNU/Linux</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>ixxx的是32位的</li>
<li>x86_64的是64位</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看进程和端口</title>
    <url>/2018/04/14/Linux-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="查看进程占用的端口号"><a href="#查看进程占用的端口号" class="headerlink" title="查看进程占用的端口号"></a>查看进程占用的端口号</h2><p>命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-atunp</span> <span class="token operator">|</span> <span class="token function">more</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Active Internet connections <span class="token punctuation">(</span>servers and established<span class="token punctuation">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:631           <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">1363</span>/cupsd
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.189.128:58887   <span class="token number">91.189</span>.88.45:80         ESTABLISHED <span class="token number">2121</span>/http
tcp6       <span class="token number">0</span>      <span class="token number">0</span> ::1:631                 :::*                    LISTEN      <span class="token number">1363</span>/cupsd
udp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:68              <span class="token number">0.0</span>.0.0:*                           <span class="token number">803</span>/dhclient<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="根据端口号查进程"><a href="#根据端口号查进程" class="headerlink" title="根据端口号查进程"></a>根据端口号查进程</h2><p>命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> <span class="token parameter variable">-i:631</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">COMMAND  PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAME
cupsd   <span class="token number">1363</span> root    5u  IPv6   <span class="token number">6338</span>      0t0  TCP localhost:ipp <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>
cupsd   <span class="token number">1363</span> root    6u  IPv4   <span class="token number">6339</span>      0t0  TCP localhost:ipp <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP定理</title>
    <url>/2019/10/04/CAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux踢出用户</title>
    <url>/2018/05/19/Linux%E8%B8%A2%E5%87%BA%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<h2 id="查看当前登录用户"><a href="#查看当前登录用户" class="headerlink" title="查看当前登录用户"></a>查看当前登录用户</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ whatis w  
w                    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  - Show <span class="token function">who</span> is logged on and what they are doing  
$ w  
09:49:30 up <span class="token number">1</span> day, <span class="token number">17</span>:19,  <span class="token number">4</span> users,  load average: <span class="token number">0.00</span>, <span class="token number">0.00</span>, <span class="token number">0.00</span>  
<span class="token environment constant">USER</span>     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT  
root     tty3     -                09:25   <span class="token number">23</span>:25   <span class="token number">0</span>.10s  <span class="token number">0</span>.08s <span class="token parameter variable">-bash</span>  
root     pts/0    <span class="token number">192.168</span>.105.188  09:32    <span class="token number">9</span>:38   <span class="token number">0</span>.02s  <span class="token number">0</span>.02s <span class="token parameter variable">-bash</span>  
root     pts/1    <span class="token number">192.168</span>.105.188  09:36    <span class="token number">9</span>:32   <span class="token number">0</span>.03s  <span class="token number">0</span>.02s <span class="token parameter variable">-bash</span>  
wilsh    pts/2    <span class="token number">192.168</span>.105.188  09:41    <span class="token number">0</span>.00s  <span class="token number">0</span>.00s  <span class="token number">0</span>.00s w  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="pkill-踢出用户"><a href="#pkill-踢出用户" class="headerlink" title="pkill 踢出用户"></a>pkill 踢出用户</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ whatis <span class="token function">pkill</span>  
<span class="token function">pkill</span> <span class="token punctuation">[</span>pgrep<span class="token punctuation">]</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  - <span class="token function">look</span> up or signal processes based on name and other attributes  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">pkill</span> <span class="token parameter variable">-kill</span> <span class="token parameter variable">-t</span> pts/2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">pkill</span> <span class="token parameter variable">-9</span> <span class="token parameter variable">-u</span> wilsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="fuser-踢出用户"><a href="#fuser-踢出用户" class="headerlink" title="fuser 踢出用户"></a>fuser 踢出用户</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ whatis <span class="token function">fuser</span>
<span class="token function">fuser</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            - identify processes using files or sockets<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">fuser</span> <span class="token parameter variable">-k</span> /dev/pts/2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>List逆序的递归和迭代</title>
    <url>/2019/10/01/List%E9%80%86%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<p>List的逆序可以有递归和迭代两种方法, 这两种方法的C++实现如下.</p>
<span id="more"></span>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

struct Node &#123;
    int data;
    Node *next;
&#125;;

void printNode(Node *node) &#123;
    Node *p &#x3D; node;
    while (p !&#x3D; nullptr) &#123;
        std::cout &lt;&lt; p-&gt;data &lt;&lt; &quot;,&quot;;
        p &#x3D; p-&gt;next;
    &#125;
    std::cout &lt;&lt; &quot;\n&quot;;
&#125;

Node * reverseNode(Node *node) &#123;
    Node *next &#x3D; nullptr;
    Node *prev &#x3D; nullptr;

    while (node !&#x3D; nullptr) &#123;
        next &#x3D; node-&gt;next;
        node-&gt;next &#x3D; prev;

        prev &#x3D; node;
        node &#x3D; next;
    &#125;

    return prev;
&#125;

Node * reverseNodeByRecursion(Node *node) &#123;
    if (node &#x3D;&#x3D; nullptr || node-&gt;next &#x3D;&#x3D; nullptr) &#123;
        return node;
    &#125;

    Node *head &#x3D; reverseNodeByRecursion(node-&gt;next);
    node-&gt;next-&gt;next &#x3D; node;
    node-&gt;next &#x3D; nullptr;

    return head;
&#125;;

int main() &#123;
    Node *head &#x3D; new Node;
    head-&gt;data &#x3D; 0;
    head-&gt;next &#x3D; nullptr;

    Node *p &#x3D; head;
    for (int i &#x3D; 1; i &lt; 10; ++i) &#123;
        p-&gt;next &#x3D; new Node;
        p &#x3D; p-&gt;next;
        p-&gt;data &#x3D; i;
        p-&gt;next &#x3D; nullptr;
    &#125;
    printNode(head);

    head &#x3D; reverseNode(head);
    printNode(head);

    head &#x3D; reverseNodeByRecursion(head);
    printNode(head);

    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小工具之LazyTime</title>
    <url>/2021/09/05/Python%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8BLazyTime/</url>
    <content><![CDATA[<p>代码见<a href="https://github.com/leiz2192/lazytime">GitHub</a>。</p>
<p>利用 <a href="https://pysimplegui.readthedocs.io/en/latest/">PySimpleGUI</a> 和 <a href="https://gitee.com/kinegratii/borax">Borax.Calendars</a>  写的一个小工具，用于显示日期、时间、星期和农历信息。</p>
<p>Win10运行参考界面如下，可拖拽，双击鼠标关闭。<br><img src="/images/20210905T004807.858.png" alt="win10"></p>
<p>时间信息获取方式：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> datetime
<span class="token keyword">from</span> borax<span class="token punctuation">.</span>calendars<span class="token punctuation">.</span>lunardate <span class="token keyword">import</span> LunarDate

<span class="token keyword">def</span> <span class="token function">get_lazy_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    prefix <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d %H:%M:%S %A"</span><span class="token punctuation">)</span>
    today <span class="token operator">=</span> LunarDate<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
    suffix <span class="token operator">=</span> <span class="token string">"&#123;&#125;月&#123;&#125; &#123;&#125;&#123;&#125;年"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>today<span class="token punctuation">.</span>cn_month<span class="token punctuation">,</span> today<span class="token punctuation">.</span>cn_day<span class="token punctuation">,</span> today<span class="token punctuation">.</span>gz_year<span class="token punctuation">,</span> today<span class="token punctuation">.</span>animal<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>
<p>通过多线程更新界面时间信息，每秒更新一次，默认 Thread 没有被动停止方法，所以继承 Thread 自定义实现。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time
<span class="token keyword">import</span> threading
<span class="token keyword">import</span> PySimpleGUI <span class="token keyword">as</span> sg

<span class="token keyword">class</span> <span class="token class-name">UpdateLazyTime</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>UpdateLazyTime<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>_stop <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>_window <span class="token operator">=</span> window

    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>_stop<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            self<span class="token punctuation">.</span>_window<span class="token punctuation">[</span><span class="token string">"lazy_time"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>get_lazy_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">stop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_stop <span class="token operator">=</span> <span class="token boolean">True</span>

sg<span class="token punctuation">.</span>theme<span class="token punctuation">(</span><span class="token string">'Reddit'</span><span class="token punctuation">)</span>
layout <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>sg<span class="token punctuation">.</span>Text<span class="token punctuation">(</span>get_lazy_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> font<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"Microsoft YaHei"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">"lazy_time"</span><span class="token punctuation">,</span> enable_events<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
window <span class="token operator">=</span> sg<span class="token punctuation">.</span>Window<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> layout<span class="token punctuation">,</span> no_titlebar<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> grab_anywhere<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> keep_on_top<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> margins<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> alpha_channel<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span>
uthread <span class="token operator">=</span> UpdateLazyTime<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
uthread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>双击关闭通过检查两次点击间隔时间小于 1s 实现，前提是 sg.Text 的 enable_events 设置为 True，否则无法接收到事件。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">last_time <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    event<span class="token punctuation">,</span> _ <span class="token operator">=</span> window<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> event <span class="token operator">!=</span> <span class="token string">"lazy_time"</span><span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">if</span> last_time <span class="token keyword">and</span> <span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> last_time<span class="token punctuation">)</span><span class="token punctuation">.</span>seconds <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    last_time <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PySimpleGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小工具之PyTomatoTimer</title>
    <url>/2021/09/05/Python%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8BPyTomatoTimer/</url>
    <content><![CDATA[<p>代码见<a href="https://github.com/leiz2192/PyTomato">GitHub</a>。</p>
<p>利用 <a href="https://pysimplegui.readthedocs.io/en/latest/">PySimpleGUI</a> 和 <a href="https://www.pygame.org/docs/">pygame</a>  写的一个小工具，用于番茄计时。</p>
<p><img src="/images/20210905T225045.549.png" alt="looks-like"></p>
<ul>
<li>记录运行和中断的次数</li>
<li>倒计时可通过配置文件 “PyTomato.json” 配置，单位为秒</li>
<li>双击倒计时部分关闭<span id="more"></span></li>
</ul>
<p>利用 pygame 播放音乐，如果音乐不存在或无法打开，则跳过播放部分。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">init_music</span><span class="token punctuation">(</span>music_file<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        pygame<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>
        mixer<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>
        mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>load<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> music_file<span class="token punctuation">)</span><span class="token punctuation">)</span>
        mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>set_volume<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>
        mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>play<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"exception when init music"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
        <span class="token keyword">global</span> USE_MUSIC
        USE_MUSIC <span class="token operator">=</span> <span class="token boolean">False</span>

<span class="token keyword">def</span> <span class="token function">music_pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> USE_MUSIC<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">music_unpause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> USE_MUSIC<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    mixer<span class="token punctuation">.</span>music<span class="token punctuation">.</span>unpause<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>利用了 Frame 实现元素的多元排列。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">init_layout</span><span class="token punctuation">(</span>default_time<span class="token punctuation">,</span> run_times<span class="token punctuation">,</span> pause_times<span class="token punctuation">)</span><span class="token punctuation">:</span>
    frame_layout <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>sg<span class="token punctuation">.</span>Button<span class="token punctuation">(</span><span class="token string">'Run'</span><span class="token punctuation">,</span> font<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"Consolas"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> button_color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'#FFFFFF'</span><span class="token punctuation">,</span> <span class="token string">'#404040'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> border_width<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'Play'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    <span class="token punctuation">[</span>sg<span class="token punctuation">.</span>Text<span class="token punctuation">(</span>times_text<span class="token punctuation">(</span>run_times<span class="token punctuation">,</span> pause_times<span class="token punctuation">)</span><span class="token punctuation">,</span> font<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"Consolas"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> auto_size_text<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">"Times"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>sg<span class="token punctuation">.</span>Text<span class="token punctuation">(</span>countdown_time_text<span class="token punctuation">(</span>default_time<span class="token punctuation">)</span><span class="token punctuation">,</span>
                     size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                     font<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"Consolas"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                     justification<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span>
                     key<span class="token operator">=</span><span class="token string">'text'</span><span class="token punctuation">,</span>
                     enable_events<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             sg<span class="token punctuation">.</span>Frame<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> layout<span class="token operator">=</span>frame_layout<span class="token punctuation">,</span> element_justification<span class="token operator">=</span><span class="token string">"center"</span><span class="token punctuation">,</span> border_width<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PySimpleGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017编译putty</title>
    <url>/2018/05/13/VS2017%E7%BC%96%E8%AF%91putty/</url>
    <content><![CDATA[<h2 id="下载putty"><a href="#下载putty" class="headerlink" title="下载putty"></a>下载putty</h2><p>从<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">putty</a>中选择”Unix source archive”下载</p>
<h2 id="加载工程"><a href="#加载工程" class="headerlink" title="加载工程"></a>加载工程</h2><p>源码下载后, 解压, 双击”windows\MSVC\putty\putty.dsp”, VS2017加载工程</p>
<h2 id="修改工程属性"><a href="#修改工程属性" class="headerlink" title="修改工程属性"></a>修改工程属性</h2><p>按如下设置VS2017工程属性.<br>此设置是为了解决问题: 错误 D8016 “/ZI”和“/Gy-”命令行选项不兼容</p>
<ul>
<li>“项目”—&gt;“属性”—&gt;“C/C++”—&gt;“常规”—&gt;“调试信息格式”—&gt;选择“程序数据库(/Zi)”或“无”</li>
<li>“项目”—&gt;“属性”—&gt;“C/C++”—&gt;“代码生成”—&gt;“启用函数集链接”—&gt;选择“是 (/Gy)”</li>
</ul>
<span id="more"></span>

<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><h3 id="修改windows-version-rc2"><a href="#修改windows-version-rc2" class="headerlink" title="修改windows\version.rc2"></a>修改windows\version.rc2</h3><p>修改前后分别如下, 解决version.rc2 cannot open include file ‘version.h’ 的问题</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"version.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"licence.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../../../version.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../../../licence.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="修改noshare-c"><a href="#修改noshare-c" class="headerlink" title="修改noshare.c"></a>修改noshare.c</h3><p>修改前后分别如下, 即注释platform_ssh_share和platform_ssh_share_cleanup的实现.<br>解决问题:</p>
<blockquote>
<p>winshare.obj : error LNK2005: _platform_ssh_share 已经在 noshare.obj 中定义<br>winshare.obj : error LNK2005: _platform_ssh_share_cleanup 已经在 noshare.obj 中定义</p>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">platform_ssh_share</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> Conf <span class="token operator">*</span>conf<span class="token punctuation">,</span>
                       Plug downplug<span class="token punctuation">,</span> Plug upplug<span class="token punctuation">,</span> Socket <span class="token operator">*</span>sock<span class="token punctuation">,</span>
                       <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>logtext<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ds_err<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>us_err<span class="token punctuation">,</span>
                       <span class="token keyword">int</span> can_upstream<span class="token punctuation">,</span> <span class="token keyword">int</span> can_downstream<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> SHARE_NONE<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">platform_ssh_share_cleanup</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
int platform_ssh_share(const char *name, Conf *conf,
                       Plug downplug, Plug upplug, Socket *sock,
                       char **logtext, char **ds_err, char **us_err,
                       int can_upstream, int can_downstream)
&#123;
    return SHARE_NONE;
&#125;

void platform_ssh_share_cleanup(const char *name)
&#123;
&#125;
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h2><p>右键工程生成解决方案.</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python调用系统命令</title>
    <url>/2019/10/04/Python%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="os-system"><a href="#os-system" class="headerlink" title="os.system"></a>os.system</h2><p>该方法在调用完shell脚本后,返回一个16位的二进制数.<br>低位为杀死所调用脚本的信号号码,高位为脚本的退出状态码.</p>
<blockquote>
<p>脚本中”exit 1”的代码执行后, os.system函数返回值的高位数则是1;<br>如果低位数是0的情况下, 则函数的返回值是0x100, 换算为10进制得到256.</p>
</blockquote>
<p>如果我们需要获得os.system的正确返回值,那使用位移运算可以还原返回值:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>test<span class="token punctuation">.</span>sh<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">>></span> <span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这是最简单的一种方法, 特点是执行的时候程序会打出cmd在linux上执行的信息.<br>使用前需要import os.</p>
<blockquote>
<p>os.system(“ls”)  仅仅在一个子终端运行系统命令, 而不能获取命令执行后的返回信息</p>
</blockquote>
<span id="more"></span>

<h2 id="os-Popen"><a href="#os-Popen" class="headerlink" title="os.Popen"></a>os.Popen</h2><p>这种调用方式是通过管道的方式来实现,函数返回一个file-like的对象,里面的内容是脚本输出的内容(可简单理解为echo输出的内容).</p>
<p>python调用Shell脚本,有两种方法:</p>
<ul>
<li>os.system(cmd)</li>
<li>os.popen(cmd),</li>
</ul>
<p>前者返回值是脚本的退出状态码, 后者的返回值是脚本执行过程中的输出内容. 实际使用时视需求情况而选择。<br>明显地,像调用”ls”这样的shell命令,应该使用popen的方法来获得内容</p>
<blockquote>
<p>popen(command [, mode=’r’ [, bufsize]]) -&gt; pipe</p>
</blockquote>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tmp <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'ls *.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen"></a>subprocess.Popen</h2><p>现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> subprocess <span class="token keyword">import</span> Popen<span class="token punctuation">,</span> PIPE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是Popen函数有一个缺陷，就是它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。解决办法是不使用wait()方法，但是也不能获得执行的返回值了。</p>
<p>Popen原型是：</p>
<blockquote>
<p>subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=false)</p>
</blockquote>
<ul>
<li>参数bufsize：指定缓冲。我到现在还不清楚这个参数的具体含义，望各个大牛指点。</li>
<li>参数executable用于指定可执行程序。一般情况下我们通过args参数来设置所要运行的程序。如果将参数shell设为 True，executable将指定程序使用的shell。在windows平台下，默认的shell由COMSPEC环境变量来指定。</li>
<li>参数stdin, stdout, stderr分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。</li>
<li>参数preexec_fn只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。</li>
<li>参数Close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。</li>
<li>如果参数shell设为true，程序将通过shell来执行。</li>
<li>参数cwd用于设置子进程的当前目录。</li>
<li>参数env是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。</li>
<li>参数Universal_newlines:不同操作系统下，文本的换行符是不一样的。如：windows下用’/r/n’表示换，而Linux下用 ‘/n’。如果将此参数设置为True，Python统一把这些换行符当作’/n’来处理。</li>
<li>参数startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。</li>
<li>subprocess.PIPE, 在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。</li>
<li>subprocess.STDOUT, 创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。</li>
</ul>
<p>Popen的方法：</p>
<ul>
<li>Popen.poll()<br>  用于检查子进程是否已经结束。设置并返回returncode属性。</li>
<li>Popen.wait()<br>  等待子进程结束。设置并返回returncode属性。</li>
<li>Popen.communicate(input=None)<br>  与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</li>
<li>Popen.send_signal(signal)<br>  向子进程发送信号。</li>
<li>Popen.terminate()<br>  停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。</li>
<li>Popen.kill()<br>  杀死子进程。</li>
<li>Popen.stdin<br>  如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。</li>
<li>Popen.stdout<br>  如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</li>
<li>Popen.stderr<br>  如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</li>
<li>Popen.pid<br>  获取子进程的进程ID。</li>
<li>Popen.returncode<br>  获取进程的返回值。如果进程还没有结束，返回None。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2019 CMake编译gtest</title>
    <url>/2020/06/14/VS2019-CMake%E8%87%AA%E7%BC%96%E8%AF%91gtest/</url>
    <content><![CDATA[<ul>
<li><p>从<a href="https://github.com/google/googletest">GitHub</a>下载gtest源码。</p>
</li>
<li><p>从VS2019选择和创建CMake项目。</p>
<span id="more"></span>
<p><img src="/images/20200614T215958.440.png" alt="select"><br><img src="/images/20200614T220154.311.png" alt="create"></p>
</li>
<li><p>将下载的gtest源码解压到项目目录下。<br><img src="/images/20200614T222711.295.png" alt="srczip"></p>
</li>
<li><p>修改项目的CMakeLists.txt文件如下。</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cmake_minimum_required (VERSION 3.8)

project (&quot;HelloCMakeGtest&quot;)

set(GTEST googletest-1.10.x)

add_subdirectory($&#123;GTEST&#125;)
include_directories($&#123;GTEST&#125;&#x2F;googletest&#x2F;include&#x2F;)

add_executable (HelloCMakeGtest &quot;HelloCMakeGtest.cpp&quot; &quot;HelloCMakeGtest.h&quot;)

target_link_libraries(LintCodeCMakeProject gtest)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>在项目的CMake设置中将“gtest_force_shared_crt”设置为True。注意需要“显示高级设置”和“显示高级变量”。不然编译会存在问题。原因是gtest默认是静态编译，与VS项目设置不一致。<br><img src="/images/20200614T224131.819.png" alt="shared"></p>
</li>
<li><p>修改项目代码文件。</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;HelloCMakeGtest.h&quot;
#include &quot;gtest&#x2F;gtest.h&quot;

int add(int n1, int n2) &#123;
    return n1 + n2;
&#125;

TEST(TestCase, test1) &#123;
    ASSERT_EQ(12, add(4, 8));
&#125;

TEST(TestCase, test2) &#123;
    EXPECT_EQ(5, add(2, 3));
&#125;

TEST(TestCase, test3) &#123;
    EXPECT_EQ(3, add(1, 2));
&#125;

int main(int argc, char* argv[]) &#123;
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>全部生成并开始执行。后续添加需要测试用例和修改CMakeLists.txt即可。<br><img src="/images/20200614T225131.721.png" alt="makerun"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Terminal集成第三方Bash</title>
    <url>/2020/06/07/Windows-Terminal/</url>
    <content><![CDATA[<p>将Git Bash和Cygwin集成到Windows Terminal中。</p>
<p>各参数说明参见<a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-settings">Windows 终端中的配置文件设置</a>。</p>
<p>我的配置如下。其中guid自定义，确保其唯一性和格式正确行即可；commandline修改为实际安装路径，其中我的Cygwin64配置是以zsh启动。</p>
<span id="more"></span>
<p>Git Bash设置：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
    <span class="token property">"guid"</span> <span class="token operator">:</span> <span class="token string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;"</span><span class="token punctuation">,</span>
    <span class="token property">"commandline"</span> <span class="token operator">:</span> <span class="token string">"C:\\Program Files\\Git\\bin\\bash.exe --login -i"</span><span class="token punctuation">,</span>
    <span class="token property">"icon"</span> <span class="token operator">:</span> <span class="token string">"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git\\gwindows_logo.png"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"Git Bash"</span><span class="token punctuation">,</span>
    <span class="token property">"startingDirectory"</span> <span class="token operator">:</span> <span class="token string">"%USERPROFILE%"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Cygwin64设置：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
    <span class="token property">"guid"</span> <span class="token operator">:</span> <span class="token string">"&#123;0caa0dad-35be-5f56-35be-0a998ec441b8&#125;"</span><span class="token punctuation">,</span>
    <span class="token property">"commandline"</span> <span class="token operator">:</span> <span class="token string">"C:\\cygwin64\\bin\\zsh.exe --login -i"</span><span class="token punctuation">,</span>
    <span class="token property">"icon"</span> <span class="token operator">:</span> <span class="token string">"C:\\cygwin64\\Cygwin.ico"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"Cygwin64"</span><span class="token punctuation">,</span>
    <span class="token property">"startingDirectory"</span> <span class="token operator">:</span> <span class="token string">"%USERPROFILE%"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>应用于所有配置文件的设置：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
    <span class="token comment">// Put settings here that you want to apply to all profiles.</span>
    <span class="token property">"acrylicOpacity"</span> <span class="token operator">:</span> <span class="token number">0.8</span><span class="token punctuation">,</span>
    <span class="token property">"closeOnExit"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"colorScheme"</span><span class="token operator">:</span> <span class="token string">"Solarized Dark"</span><span class="token punctuation">,</span>
    <span class="token property">"padding"</span> <span class="token operator">:</span> <span class="token string">"0, 0, 0, 0"</span><span class="token punctuation">,</span>
    <span class="token property">"cursorShape"</span> <span class="token operator">:</span> <span class="token string">"bar"</span><span class="token punctuation">,</span>
    <span class="token property">"fontSize"</span> <span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    <span class="token property">"snapOnInput"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"historySize"</span> <span class="token operator">:</span> <span class="token number">9001</span><span class="token punctuation">,</span>
    <span class="token property">"useAcrylic"</span> <span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>apt-get清理软件包</title>
    <url>/2019/11/03/apt-get%E6%B8%85%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li><p>apt-get autoclean</p>
<p>  如果你的硬盘空间不大的话，可以定期运行这个程序，将已经删除了的软件包的.deb安装文件从硬盘中删除掉。如果你仍然需要硬盘空间的话，可以试试apt-get clean，这会把你已安装的软件包的安装包也删除掉，当然多数情况下这些包没什么用了，因此这是个为硬盘腾地方的好办法。</p>
</li>
<li><p>apt-get clean</p>
<p>  类似上面的命令，但它删除包缓存中的所有包。这是个很好的做法，因为多数情况下这些包没有用了。但如果你是拨号上网的话，就得重新考虑了。</p>
</li>
<li><p>apt-get autoremove</p>
<p>  删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包。</p>
</li>
<li><p>apt-get remove 软件包名称</p>
<p>  删除已安装的软件包（保留配置文件）。</p>
</li>
<li><p>apt-get –purge remove 软件包名称</p>
<p>   删除已安装包（不保留配置文件)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>cout的格式化</title>
    <url>/2019/10/04/cout%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>STL cout的格式化收集整理如下, 以便查阅.</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>cout是STL库提供的一个iostream实例，拥有ios_base基类的全部函数和成员数据.<br>进行格式化操作可以直接利用setf/unsetf函数和flags函数.</p>
<blockquote>
<p>cout维护一个当前的格式状态, setf/unsetf函数是在当前的格式状态上追加或删除指定的格式, flags则是将当前格式状态全部替换为指定的格式。</p>
</blockquote>
<p>cout为这个函数提供了如下参数（可选格式）：</p>
<ul>
<li>ios::dec            以10进制表示整数</li>
<li>ios::hex            以16进制表示整数</li>
<li>ios::oct            以8进制表示整数</li>
<li>ios::showbase       为整数添加一个表示其进制的前缀</li>
<li>ios::internal       在符号位和数值的中间插入需要数量的填充字符以使串两端对齐</li>
<li>ios::left           在串的末尾插入填充字符以使串居左对齐</li>
<li>ios::right          在串的前面插入填充字符以使串居右对齐</li>
<li>ios::boolalpha      将bool类型的值以true或flase表示，而不是1或0</li>
<li>ios::fixed          将符点数按照普通定点格式处理（非科学计数法）</li>
<li>ios::scientific     将符点数按照科学计数法处理（带指数域）</li>
<li>ios::showpoint      在浮点数表示的小数中强制插入小数点（默认情况是浮点数表示的整数不显示- 小数点）</li>
<li>ios::showpos        强制在正数前添加+号</li>
<li>ios::skipws         忽略前导的空格（主要用于输入流，如cin）</li>
<li>ios::unitbuf        在插入（每次输出）操作后清空缓存</li>
<li>ios::uppercase      强制大写字母</li>
</ul>
<span id="more"></span>

<p>以上每一种格式都占用独立的一位，因此可以用“|”（位或）运算符组合使用。<br>调用setf/unsetf或flags设置格式一般按如下方式进行：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout.setf(ios::right | ios::hex);           &#x2F;&#x2F;设置16进制右对齐
cout.setf(ios::right, ios::adjustfield);    &#x2F;&#x2F;取消其它对齐，设置为右对齐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>setf可接受一个或两个参数，一个参数的版本为设置指定的格式，后一个参数指定了删除的格式。</p>
<p>三个已定义的组合格式为：</p>
<ul>
<li>ios::adjustfield    对齐格式的组合位</li>
<li>ios::basefield      进制的组合位</li>
<li>ios::floatfield     浮点表示方式的组合位</li>
</ul>
<p>设置格式之后，下面所有使用cout进行的输出都会按照指定的格式状态执行。<br>但是如果在一次输出过程中需要混杂多种格式，使用cout的成员函数来处理就显得很不方便了。</p>
<p>STL另提供了一套<em>iomanip</em>库可以满足这种使用方式。<em>iomanip</em>库中将每一种格式的设置和删除都进行了函数级的同名封装，比如fixed函数，就可以将一个ostream的对象作为参数，在内部调用setf函数对其设置ios::fixed格式后再返回原对象。</p>
<p>此外<em>iomanip</em>还提供了setiosflags、setbase、setfill、setw、setprecision等方便的格式控制函数，下文会逐一进行介绍。大多数示例代码都会使用到<em>iomanip</em>，因此默认包含的头文件均为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>将输出内容按指定的宽度对齐，需要用到ios::right、ios::left、ios::internal和iomanip里的setw。</p>
<p>其中 setw用于指定要输出内容的对齐宽度。以下两段代码的结果完全相同，前面是一个浮点数-456.98，后面紧跟着一个字符串“The End”以及换行符“endl”。</p>
<p><em>代码一：</em></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout.flags(ios::left); &#x2F;&#x2F;左对齐
    cout &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl;
    cout.flags(ios::internal); &#x2F;&#x2F;两端对齐
    cout &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl;
    cout.flags(ios::right); &#x2F;&#x2F;右对齐
    cout &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>代码二：</em></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout &lt;&lt; left &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl; &#x2F;&#x2F;左对齐
    cout &lt;&lt; internal &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl; &#x2F;&#x2F;两端对齐
    cout &lt;&lt; right &lt;&lt; setw(10) &lt;&lt; -456.98 &lt;&lt; &quot;The End&quot; &lt;&lt; endl; &#x2F;&#x2F;右对齐
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-456.98</span> The End
- <span class="token number">456</span>.98The End
<span class="token parameter variable">-456.98The</span> End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里要额外说明的一点是，setw函数会用当前的填充字符控制对齐位置，默认的填充字符是空格。</p>
<p>可以通过<code>&lt;iomanip&gt;</code>的setfill来设置填充字符，比如下面的代码用字符“0”作为填充字符：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; setw(10) &lt;&lt; 45698 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： 0000045698</p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>输出整数的格式有按不同进制数出：ios::hex（16进制）, ios::dec（10进制）, ios::oct（ 8进制）, 也可强制其输出符号（正数也加上“+”号前缀），对于16进制的输出还可配合<strong>ios::uppercase</strong>使所有字母以大写表示。</p>
<p>代码示例如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout.setf(ios::showpos | ios::uppercase);
    cout &lt;&lt; hex &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    cout &lt;&lt; dec &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    cout &lt;&lt; oct &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    cout.unsetf(ios::showpos | ios::uppercase);
    cout &lt;&lt; hex &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    cout &lt;&lt; dec &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    cout &lt;&lt; oct &lt;&lt; setw(4) &lt;&lt; 12 &lt;&lt; setw(12) &lt;&lt; -12 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： C FFFFFFF4 +12 -12 14 37777777764 c fffffff4 12 -12 14 37777777764</p>
<p>利用<code>&lt;iomanip&gt;</code>的setbase函数同样可以设置整数的三种进制，参数分别为8、10和16，但使用起来比上面的方法还更复杂一些，除非是特殊的代码规范要求（有些规范要求避免将常量直接作为表达式），一般不建议使用setbase。</p>
<p>此外，还可以利用ios::showbase来为整数的前面加一个表示进制的前缀，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout &lt;&lt; showbase &lt;&lt; setw(4) &lt;&lt; hex &lt;&lt; 32 &lt;&lt; setw(4) &lt;&lt; oct &lt;&lt; 32 &lt;&lt; endl;
    cout &lt;&lt; noshowbase &lt;&lt; setw(4) &lt;&lt; hex &lt;&lt; 32 &lt;&lt; setw(4) &lt;&lt; oct &lt;&lt; 32 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： 0x20 040 20 40</p>
<p>上面代码中的showbase/noshobase也可以用cout的setf来代替，其结果是完全相同的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout.setf(ios::showbase);
    cout &lt;&lt; setw(4) &lt;&lt; hex &lt;&lt; 32 &lt;&lt; setw(4) &lt;&lt; oct &lt;&lt; 32 &lt;&lt; endl;
    cout.unsetf(ios::showbase);
    cout &lt;&lt; setw(4) &lt;&lt; hex &lt;&lt; 32 &lt;&lt; setw(4) &lt;&lt; oct &lt;&lt; 32 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><p>小数可分为两种格式类型，一种是定点表示“ios::fixed”（不带指数域），另一种是科学计数法表示“ios::scientific”（带指数域）。与<code>&lt;iomanip&gt;</code>的setprecision配合使用，可以表示指定小数点后面的保留位数（四舍五入）。</p>
<p>示例代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout.setf(ios::fixed);
    cout &lt;&lt; setprecision(0) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(1) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(2) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(3) &lt;&lt; 12.05 &lt;&lt; endl;
    cout.setf(ios::scientific, ios::floatfield);
    cout &lt;&lt; setprecision(0) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(1) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(2) &lt;&lt; 12.05 &lt;&lt; endl;
    cout &lt;&lt; setprecision(3) &lt;&lt; 12.05 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： 12 12.1 12.05 12.050 1.205000e+001 1.2e+001 1.21e+001 1.205e+001</p>
<p>需要注意的是，有时会因为机器的精度问题导致四舍五入的结果不正确。这种问题一般需要手动修正，见如下代码示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; 2.05 &lt;&lt; endl;
    cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; 2.05 + 1e-8 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： 2.0 2.1</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的输出处理主要是对齐，这一点在第二部分已经介绍过了，下面主要介绍字符串的输入方法。</p>
<p>为了方便起见，我们使用<code>&lt;string&gt;</code>库。在输入字符串时，可以利用<code>&lt;string&gt;</code>库提供的getline函数读取整行数据。</p>
<p>getline函数有两个版本:</p>
<p>第一个版本有两个参数，第一个参数指定输入流（比如cin），第二个参数指定一个string对象。getline会读取屏幕上输入的字符，直到遇到换行符“\n”为止；</p>
<p>第二个版本有三个参数，前两个与第一个版本相同，第三个参数为指定的结束字符。</p>
<p>注意，getline不会读入默认或指定的结束字符，但在调用之后读取的位置已经跳过结束字符。调用示例代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main(void) &#123;
    string str1, str2;
    getline(cin, str1);
    cin &gt;&gt; str2;
    cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输入： abc abc</p>
<p>结果： abc abc</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>由于调用系统函数在屏幕上逐个显示字符是很慢的，因此cin/cout为了加快速度使用缓冲区技术，粗略的讲就是暂时不输出指定的字符，而是存放在缓冲区中，在合适的时机一次性输出到屏幕上。</p>
<p>如果单纯使用C++的输入/输出流来操作字符是不存在同步的问题的，但是如果要和C标准库的stdio库函数混合使用就必须要小心的处理缓冲区了。</p>
<p>如果要与scanf和printf联合使用，务必在调用cout前加上cout.sync_with_stdio()，设置与stdio同步，否则输出的数据顺序会发生混乱。</p>
<p>flush和endl都会将当前缓冲区中的内容立即写入到屏幕上，而unitbuf/nounitbuf可以禁止或启用缓冲区。</p>
<p>示例代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
int main(void) &#123;
    cout &lt;&lt; 123 &lt;&lt; flush &lt;&lt; 456 &lt;&lt; endl;
    cout &lt;&lt; unitbuf &lt;&lt; 123 &lt;&lt; nounitbuf &lt;&lt; 456 &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果： 123456 123456</p>
<h2 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h2><p>示例代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
struct COMMODITY &#123; string Name; int Id; int Cnt; double Price; &#125;;
int main(void) &#123;
    COMMODITY cmd[] &#x3D; &#123;
        &#123;&quot;Fruit&quot;, 0x101, 50, 5.268&#125;,
        &#123;&quot;Juice&quot;, 0x102, 20, 8.729&#125;,
        &#123;&quot;Meat&quot;, 0x104, 30, 10.133&#125;,
    &#125;;
    cout &lt;&lt; left &lt;&lt; setw(8) &lt;&lt; &quot;NAME&quot; &lt;&lt; right &lt;&lt; setw(8) &lt;&lt; &quot;ID&quot;;
    cout &lt;&lt; right &lt;&lt; setw(8) &lt;&lt; &quot;COUNT&quot; &lt;&lt; right &lt;&lt; setw(8) &lt;&lt; &quot;PRICE&quot; &lt;&lt; endl;
    for (int i &#x3D; 0; i &lt; sizeof(cmd) &#x2F; sizeof(cmd[0]); ++i) &#123;
        cout &lt;&lt; left &lt;&lt; setw(8) &lt;&lt; cmd[i].Name;
        cout &lt;&lt; right &lt;&lt; hex &lt;&lt; showbase &lt;&lt; setw(8) &lt;&lt; cmd[i].Id;
        cout &lt;&lt; dec &lt;&lt; noshowbase &lt;&lt; setw(8) &lt;&lt; cmd[i].Cnt;
        cout &lt;&lt; fixed &lt;&lt; setw(8) &lt;&lt; setprecision(2) &lt;&lt; cmd[i].Price &lt;&lt; endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">NAME          ID   COUNT   PRICE
Fruit      0x101      <span class="token number">50</span>    <span class="token number">5.27</span>
Juice      0x102      <span class="token number">20</span>    <span class="token number">8.73</span>
Meat       0x104      <span class="token number">30</span>   <span class="token number">10.13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数重载和函数重写</title>
    <url>/2020/12/05/cplusplus-override-overload-redefine/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>对于C++中经常出现的函数名称相同但是参数列表或者返回值不同的函数，主要存在三种情况：</p>
<h3 id="函数重写override"><a href="#函数重写override" class="headerlink" title="函数重写override"></a>函数重写override</h3><p>函数重载主要实现了父类与子类之间的多态性，子类中定义与父类中名称和参数以及返回值都相同的虚函数。</p>
<ul>
<li>重写的函数不能是static函数，必须是virtual函数,即函数在原始的基类中被声明为虚函数；</li>
<li>重写函数与基类函数分在两个类的声明和定义中，这也就导致二者的作用域不同；</li>
<li>重写函数的名称、参数列表以及返回值（即函数原型）都要与基类的函数相同；</li>
<li>重写函数的访问修饰符可以不同，尽管virtual函数是private的，在派生类中重写的函数可以是public或protect的</li>
</ul>
<h3 id="函数重载overload"><a href="#函数重载overload" class="headerlink" title="函数重载overload"></a>函数重载overload</h3><p>指函数名称相同但是参数类型或者参数顺序不同的相同作用域中的函数，函数重载不能靠返回值来进行区分；</p>
<h3 id="重定义redefine"><a href="#重定义redefine" class="headerlink" title="重定义redefine"></a>重定义redefine</h3><p>指子类重新定义父类中的非虚函数（<code>参数列表可以不同</code>），这样父类中的对应函数将被隐藏。</p>
<span id="more"></span>
<p>比如以下程序编译时提示<code>error: no matching function for call to ‘B::func(int)’</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

class A &#123;
public:
    void func(int a) &#123;
        std::cout &lt;&lt; &quot;A: &quot; &lt;&lt; a &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;;

class B : public A &#123;
public:
    void func(int a, int b) &#123;
        std::cout &lt;&lt; &quot;B: &quot; &lt;&lt; a &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;;

int main() &#123;
    B b;
    b.func(8);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="重写override与重载overload的区别"><a href="#重写override与重载overload的区别" class="headerlink" title="重写override与重载overload的区别"></a>重写override与重载overload的区别</h2><ul>
<li>函数重写是子类和父类之间的继承关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系；</li>
<li>重写需要子类和父类中的两个函数的函数原型完全相同；重载要求两个函数参数列表不同；</li>
<li>在重写关系中，调用具体调用哪一个函数是根据（对象对应存储空间的实际类型）为准的，这涉及到动态绑定和静态绑定的问题，也就是虚函数的调用机制，而函数重载主要是靠形参列表的不同来区分具体调用哪个函数的。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title>const in C++</title>
    <url>/2020/01/01/const-in-C/</url>
    <content><![CDATA[<p>C++中const可用于变量, 指针, 函数和类.</p>
<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>const修饰的变量的值不能再修改, 编译器也可以对其进行数据静态类型检查. 所以用const声明的变量可以保证类型安全, 用以取代C中的宏定义.</p>
<p>const定义的常量在C中是全局的, 在C++中则视声明位置而定.</p>
<h2 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h2><p>使用指针时涉及到两个对象: 该指针本身和被它所指的对象.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const char *pc;    &#x2F;&#x2F; pc是到const char的指针, 即*pc的内容不可修改, 但pc可以指向其他字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char const *pc;    &#x2F;&#x2F; 同&quot;const char *pc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char *const pc;    &#x2F;&#x2F; pc到char的const指针, 即*pc的内容可以修改, 但pc不能指向其他字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<span id="more"></span>

<h2 id="函数中使用"><a href="#函数中使用" class="headerlink" title="函数中使用"></a>函数中使用</h2><h3 id="修饰函数参数"><a href="#修饰函数参数" class="headerlink" title="修饰函数参数"></a>修饰函数参数</h3><p>const常用于修饰函数的指针参数和引用参数, 一是表示参数的内容不可修改, 二是可以提高效率.</p>
<h3 id="修饰函数返回值"><a href="#修饰函数返回值" class="headerlink" title="修饰函数返回值"></a>修饰函数返回值</h3><p>如果函数的返回值是指针或引用, 增加const修饰后, 则返回值不能被直接修改, 且返回值只能被赋值给const修饰的同类型变量.</p>
<h2 id="类中使用"><a href="#类中使用" class="headerlink" title="类中使用"></a>类中使用</h2><h3 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h3><p>const的成员变量不能被修改, 且只能在初始化列表中赋值.</p>
<h3 id="修饰成员函数"><a href="#修饰成员函数" class="headerlink" title="修饰成员函数"></a>修饰成员函数</h3><p>任何不会修改数据成员的成员函数都应用const修饰.<br>修饰形式:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int func(int) const;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于使用了const修饰的成员函数:</p>
<ul>
<li>不能修改成员变量</li>
<li>不能调用非const成员函数</li>
<li>const类对象只能调用const成员函数</li>
<li>const不能与static同时使用. const其实是用于修饰this指针, 即this指向的内容不可修改. 但static修饰的静态成员是类的而不是类对象的, 不含有this指针. 所以const和static不能共用.</li>
</ul>
<p>另外, 构造函数和析构函数也是成员函数, 但不能使用const修饰, 因为两者都是在对成员变量修改.</p>
<h3 id="修饰类对象"><a href="#修饰类对象" class="headerlink" title="修饰类对象"></a>修饰类对象</h3><ul>
<li>对象的任何成员不能被修改</li>
<li>只能调用const成员函数</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Python的简单FTP服务器</title>
    <url>/2020/11/21/simple-ftp-server-by-python/</url>
    <content><![CDATA[<p>代码见<a href="https://github.com/leiz2192/Python/tree/master/PyFtpServer">GitHub</a>。</p>
<p>UI使用基于tk的PySimpleGUI，FTP服务器使用pyftpdlib，使用pyinstaller进行打包。</p>
<ul>
<li><p>Win10运行参考界面<br><img src="/images/20201129T195324.321.png" alt="win界面"></p>
</li>
<li><p>Ubuntu20.04运行参考界面<br><img src="/images/20201129T203840.135.png" alt="ubunt界面"></p>
</li>
<li><p>打包命令</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PyInstaller <span class="token parameter variable">-F</span> <span class="token parameter variable">-w</span> py_ftp_server.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PySimpleGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>略探 gRPC</title>
    <url>/2025/05/02/get-to-know-grpc/</url>
    <content><![CDATA[<p>RPC 作为一款由 Google 开发的开源 RPC 框架，凭借其先进的设计理念和强大的功能特性，成为众多开发者的首选。<br>本文将从核心概念、特性优势到实际应用几个方面略探 gRPC。</p>
<span id="more"></span>

<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>gRPC 基于 HTTP/2 协议构建，采用 Protocol Buffers（protobuf）作为默认的接口定义语言（IDL）。<br>HTTP/2 协议具备多路复用、头部压缩、二进制分帧等特性，这使得 gRPC 在网络传输上拥有极高的效率，能够有效减少延迟、提升吞吐量。<br>而 protobuf 是一种高效的结构化数据序列化机制，它以二进制格式存储数据，不仅占用空间小，而且解析速度极快，能够显著降低数据传输和处理的开销。​<br>从架构层面来看，gRPC 包含服务端和客户端两部分。<br>开发者通过 .proto 文件定义服务接口和消息结构，随后使用 protoc 编译器生成对应编程语言的代码，涵盖 Java、Python、Go、C++ 等众多主流语言。<br>服务端实现定义好的服务接口，对外提供服务；客户端则通过生成的代码调用服务端的方法，实现远程过程调用，整个过程简洁且高效。</p>
<h1 id="特性优势"><a href="#特性优势" class="headerlink" title="特性优势"></a>特性优势</h1><p>gRPC 具有以下几个突出的特性优势：</p>
<ul>
<li>高效的序列化和反序列化：gRPC 使用 protobuf 作为默认的序列化格式，能够高效地处理复杂的数据结构，减少数据传输的开销。</li>
<li>支持多种编程语言：gRPC 支持多种主流编程语言，开发者可以根据自己的需求选择合适的语言进行开发，提高开发效率。</li>
<li>支持双向流式通信：gRPC 支持双向流式通信，客户端和服务端可以同时发送和接收多个消息，适用于实时数据传输场景。</li>
<li>支持元数据和认证：gRPC 支持元数据和认证机制，开发者可以在请求和响应中添加自定义的元数据，实现身份验证和授权等功能。</li>
<li>支持负载均衡和故障转移：gRPC 内置了负载均衡和故障转移机制，能够自动处理服务端的负载均衡和故障转移，提高系统的可用性和稳定性。</li>
<li>支持多种传输协议：gRPC 支持多种传输协议，包括 HTTP/2、gRPC-Web、gRPC-WebSocket 等（暂未支持 QUIC），开发者可以根据自己的需求选择合适的协议进行通信。</li>
</ul>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>gRPC 在实际应用中具有广泛的应用场景，以下是一些常见的应用场景：</p>
<ul>
<li>微服务架构：gRPC 可以用于构建微服务架构，将不同的服务之间通过 gRPC 进行通信，实现服务的解耦和扩展。</li>
<li>分布式系统：gRPC 可以用于构建分布式系统，实现不同节点之间的远程过程调用，提高系统的可扩展性和性能。</li>
<li>实时数据传输：gRPC 支持双向流式通信，可以用于实时数据传输，如实时聊天、实时监控等场景。</li>
<li>跨语言调用：gRPC 支持多种编程语言，开发者可以根据自己的需求选择合适的语言进行开发，实现跨语言调用。</li>
<li>云原生应用：gRPC 可以用于构建云原生应用，实现服务的弹性扩展和快速部署，提高系统的可维护性和可扩展性。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>gRPC 作为一款高效、灵活、可扩展的 RPC 框架，具有丰富的特性优势和广泛的应用场景。<br>无论是微服务架构、分布式系统还是实时数据传输等场景，gRPC 都能够提供高效、可靠的远程过程调用解决方案。<br>开发者可以根据自己的需求选择合适的语言和协议进行开发，实现跨语言调用和云原生应用。​</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant box保存路径修改</title>
    <url>/2019/10/07/vagrant-box%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>vagrant add box时默认保存在目录<code>~/.vagrant.d</code>. 可以通过设置<code>VAGRANT_HOME</code>环境变量改变默认位置.</p>
<blockquote>
<p>VAGRANT_HOME can be set to change the directory where Vagrant stores global state. By default, this is set to ~/.vagrant.d. The Vagrant home directory is where things such as boxes are stored, so it can actually become quite large on disk.</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>Windows：</p>
<p>用户变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setx VAGRANT_HOME<span class="token string">"X:/your/path"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>系统变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setx VAGRANT_HOME<span class="token string">"X:/your/path"</span>/M<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>Linux</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">VAGRANT_HOME</span><span class="token operator">=</span><span class="token string">'/path/to/vagrant_home'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant使用</title>
    <url>/2019/10/07/vagrant%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="VirtualBox安装"><a href="#VirtualBox安装" class="headerlink" title="VirtualBox安装"></a>VirtualBox安装</h2><p>VirtualBox是Oracle开源的虚拟化系统，它支持多个平台，所以你可以到<a href="https://www.virtualbox.org/wiki/Downloads/"><em>官方网站</em></a>下载适合你平台的VirtualBox最新版本并安装，安装过程选择默认设置即可。</p>
<h2 id="Vagrant安装"><a href="#Vagrant安装" class="headerlink" title="Vagrant安装"></a>Vagrant安装</h2><p>在<a href="http://www.vagrantup.com/downloads.html"><em>官方网站</em></a>下载安装包,安装过程选择默认设置即可。</p>
<p>尽量下载最新的程序，因为VirtualBox经常升级，升级后有些接口会变化，老的Vagrant可能无法使用。</p>
<p>检测安装是否成功的方法是，在终端命令行工具中输入vagrant，看看程序是不是已经可以运行了。如果不行，请检查一下<code>$PATH</code>里面是否包含vagrant所在的路径。</p>
<span id="more"></span>

<h2 id="Vagrant配置"><a href="#Vagrant配置" class="headerlink" title="Vagrant配置"></a>Vagrant配置</h2><p>一个打包好的操作系统在Vagrant中称为Box，即Box是一个打包好的操作系统环境。<a href="http://www.vagrantbox.es/">vagrantbox.es</a>上面有大家熟知的大多数操作系统。建议下载后安装，这样安装过程快速。</p>
<h2 id="建立开发环境目录"><a href="#建立开发环境目录" class="headerlink" title="建立开发环境目录"></a>建立开发环境目录</h2><p>根据自己的系统不同建立一个目录就可以。</p>
<h2 id="下载box"><a href="#下载box" class="headerlink" title="下载box"></a>下载box</h2><p>前面讲了box是一个操作系统环境，实际上它是一个zip包，包含了Vagrant的配置信息和VirtualBox的虚拟机镜像文件.比如<a href="http://files.vagrantup.com/lucid64.box"><em>Ubuntu lucid 64</em></a></p>
<h2 id="添加box"><a href="#添加box" class="headerlink" title="添加box"></a>添加box</h2><p>添加box的命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant box <span class="token function">add</span> base 远端的box地址或者本地的box文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>base是box的名称，可以是任意的字符串，base是默认名称，主要用来标识一下你添加的box，后面的命令都是基于这个标识来操作的。</p>
<p>例子：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant box <span class="token function">add</span> base http://files.vagrantup.com/lucid64.box
vagrant box <span class="token function">add</span> base https://dl.dropbox.com/u/7225008/VagrantCentOS-6.3-x86_64-minimal.box
vagrant box <span class="token function">add</span> base CentOS-6.3-x86_64-minimal.box
vagrant box <span class="token function">add</span> <span class="token string">"CentOS 6.3 x86_64 minimal"</span> CentOS-6.3-x86_64-minimal.box<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant box <span class="token function">add</span> base lucid64.box<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>安装过程的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Downloading or copying the box<span class="token punctuation">..</span>.
Extracting box<span class="token punctuation">..</span>.te: <span class="token number">47</span>.5M/s, Estimated <span class="token function">time</span> remaining: --:--:--<span class="token punctuation">)</span>
Successfully added box <span class="token string">'base'</span> with provider <span class="token string">'virtualbox'</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>box中的镜像文件在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化的命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果你添加的box名称不是base，那么需要在初始化的时候指定名称，例如</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant init <span class="token string">"CentOS 6.3 x86_64 minimal"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>初始化过程的信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A <span class="token variable"><span class="token variable">`</span>Vagrantfile<span class="token variable">`</span></span> has been placed <span class="token keyword">in</span> this directory.
You are now ready to <span class="token variable"><span class="token variable">`</span>vagrant up<span class="token variable">`</span></span> your first virtual environment<span class="token operator">!</span>
Please <span class="token builtin class-name">read</span> the comments <span class="token keyword">in</span> the Vagrantfile as well as documentation on <span class="token variable"><span class="token variable">`</span>vagrantup.com<span class="token variable">`</span></span> <span class="token keyword">for</span> <span class="token function">more</span> information on using Vagrant.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><p>启动虚拟机的命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动过程的信息:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Bringing machine <span class="token string">'default'</span> up with <span class="token string">'virtualbox'</span> provider<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Importing base box <span class="token string">'base'</span><span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Matching MAC address <span class="token keyword">for</span> NAT networking<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Setting the name of the VM<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Clearing any previously <span class="token builtin class-name">set</span> forwarded ports<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Creating shared folders metadata<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Clearing any previously <span class="token builtin class-name">set</span> network interfaces<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Preparing network interfaces based on configuration<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Forwarding ports<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> -- <span class="token number">22</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2222</span> <span class="token punctuation">(</span>adapter <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Booting VM<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Waiting <span class="token keyword">for</span> VM to boot. This can take a few minutes.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> VM booted and ready <span class="token keyword">for</span> use<span class="token operator">!</span>
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> Mounting shared folders<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>default<span class="token punctuation">]</span> -- /vagrant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="连接到虚拟机"><a href="#连接到虚拟机" class="headerlink" title="连接到虚拟机"></a>连接到虚拟机</h2><p>上面已经启动了虚拟机，之后我们就可以通过ssh来连接到虚拟机了。比如在我的开发机中可以像这样来连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vagrant <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>连接到虚拟机后的信息如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Linux lucid64 <span class="token number">2.6</span>.32-38-server <span class="token comment">#83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux</span>
Ubuntu <span class="token number">10.04</span>.4 LTS

Welcome to the Ubuntu Server<span class="token operator">!</span>
 * Documentation:  http://www.ubuntu.com/server/doc
New release <span class="token string">'precise'</span> available.
Run <span class="token string">'do-release-upgrade'</span> to upgrade to it.

Welcome to your Vagrant-built virtual machine.
Last login: Fri Sep <span class="token number">14</span> 07:31:39 <span class="token number">2012</span> from <span class="token number">10.0</span>.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样我们就可以像连接到一台服务器一样进行操作了。<br><em>Window机器不支持这样的命令，必须使用第三方客户端来进行连接，例如putty、Xshell等.</em></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">主机地址: <span class="token number">127.0</span>.0.1
端口: <span class="token number">2222</span>
用户名: vagrant
密码: vagrant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>vimrc配置</title>
    <url>/2018/04/14/vimrc%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>以下是收集整理个人使用的.vimrc文件配置.</p>
<span id="more"></span>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> nocompatible <span class="token string">" 关闭 vi 兼容模式
syntax on "</span> 自动语法高亮
colorscheme desert <span class="token string">" 设定配色方案
set number "</span> 显示行号
<span class="token builtin class-name">set</span> cursorline <span class="token string">" 突出显示当前行
set ruler "</span> 打开状态栏标尺
<span class="token builtin class-name">set</span> <span class="token assign-left variable">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span> <span class="token string">" 设定 &lt;&lt; 和 >> 命令移动时的宽度为 4
set softtabstop=4 "</span> 使得按退格键时可以一次删掉 <span class="token number">4</span> 个空格
<span class="token builtin class-name">set</span> <span class="token assign-left variable">tabstop</span><span class="token operator">=</span><span class="token number">4</span> <span class="token string">" 设定 tab 长度为 4
set nobackup "</span> 覆盖文件时不备份
<span class="token builtin class-name">set</span> autochdir <span class="token string">" 自动切换当前目录为当前文件所在的目录
filetype plugin indent on "</span> 开启插件
<span class="token builtin class-name">set</span> <span class="token assign-left variable">backupcopy</span><span class="token operator">=</span>yes <span class="token string">" 设置备份时的行为为覆盖
set ignorecase smartcase "</span> 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感
<span class="token builtin class-name">set</span> nowrapscan <span class="token string">" 禁止在搜索到文件两端时重新搜索
set incsearch "</span> 输入搜索内容时就显示搜索结果
<span class="token builtin class-name">set</span> hlsearch <span class="token string">" 搜索时高亮显示被找到的文本
set noerrorbells "</span> 关闭错误信息响铃
<span class="token builtin class-name">set</span> novisualbell <span class="token string">" 关闭使用可视响铃代替呼叫
set t_vb= "</span> 置空错误铃声的终端代码
<span class="token string">" set showmatch "</span> 插入括号时，短暂地跳转到匹配的对应括号
<span class="token string">" set matchtime=2 "</span> 短暂跳转到匹配括号的时间
<span class="token builtin class-name">set</span> magic <span class="token string">" 设置魔术
set hidden "</span> 允许在有未保存的修改时切换缓冲区，此时的修改由 <span class="token function">vim</span> 负责保存
<span class="token builtin class-name">set</span> guioptions-<span class="token operator">=</span>T <span class="token string">" 隐藏工具栏
set guioptions-=m "</span> 隐藏菜单栏
<span class="token builtin class-name">set</span> smartindent <span class="token string">" 开启新行时使用智能自动缩进
set backspace=indent,eol,start "</span> 不设定在插入状态无法用退格键和 Delete 键删除回车符
<span class="token builtin class-name">set</span> <span class="token assign-left variable">cmdheight</span><span class="token operator">=</span><span class="token number">1</span> <span class="token string">" 设定命令行的行数为 1
set laststatus=2 "</span> 显示状态栏 <span class="token punctuation">(</span>默认值为 <span class="token number">1</span>, 无法显示状态栏<span class="token punctuation">)</span>

<span class="token string">" 设置在状态行显示的信息
set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\
"</span> <span class="token builtin class-name">set</span> foldenable <span class="token string">" 开始折叠
"</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">foldmethod</span><span class="token operator">=</span>syntax <span class="token string">" 设置语法折叠
"</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">foldcolumn</span><span class="token operator">=</span><span class="token number">0</span> <span class="token string">" 设置折叠区域的宽度
"</span> setlocal <span class="token assign-left variable">foldlevel</span><span class="token operator">=</span><span class="token number">1</span> <span class="token string">" 设置折叠层数为

"</span> 中文显示
<span class="token builtin class-name">set</span> <span class="token assign-left variable">fileencodings</span><span class="token operator">=</span>utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
<span class="token builtin class-name">set</span> <span class="token assign-left variable">termencoding</span><span class="token operator">=</span>utf-8
<span class="token builtin class-name">set</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span>utf-8

<span class="token builtin class-name">set</span> <span class="token function">paste</span>
<span class="token builtin class-name">set</span> expandtab

noremap <span class="token operator">&lt;</span>Space<span class="token operator">></span> *N
noremap <span class="token operator">&lt;</span>C-<span class="token punctuation">\</span><span class="token operator">></span> :q<span class="token operator">!</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>

highlight CursorLine   <span class="token assign-left variable">cterm</span><span class="token operator">=</span>NONE <span class="token assign-left variable">ctermbg</span><span class="token operator">=</span>black <span class="token assign-left variable">ctermfg</span><span class="token operator">=</span>green <span class="token assign-left variable">guibg</span><span class="token operator">=</span>NONE <span class="token assign-left variable">guifg</span><span class="token operator">=</span>NONE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>不能被继承的类</title>
    <url>/2019/09/01/%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<p>虚继承模板类NoCopyable的类不可再被继承。</p>
<span id="more"></span>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

template &lt;typename T&gt;
class NoCopyable &#123;
public:
    friend T;

private:
    NoCopyable() &#123;&#125;
    virtual ~NoCopyable() throw() &#123;&#125;

    NoCopyable(const NoCopyable &amp;);
    const NoCopyable &amp; operator&#x3D;(const NoCopyable &amp;);
&#125;;

class Base : virtual public NoCopyable&lt;Base&gt; &#123;
public:
    Base()  &#123;
        std::cout &lt;&lt; __TIME__ &lt;&lt; &quot;,&quot; &lt;&lt; __FUNCTION__ &lt;&lt; &quot;\n&quot;;
    &#125;

    ~Base() throw ()    &#123;
        std::cout &lt;&lt; __TIME__ &lt;&lt; &quot;,&quot; &lt;&lt; __FUNCTION__ &lt;&lt; &quot;\n&quot;;
    &#125;

private:
    Base(const Base &amp;);
    const Base &amp; operator&#x3D;(const Base &amp;);
&#125;;

class Derived : public Base &#123;
public:
    Derived()    &#123;
        std::cout &lt;&lt; __TIME__ &lt;&lt; &quot;,&quot; &lt;&lt; __FUNCTION__ &lt;&lt; &quot;\n&quot;;
    &#125;

    ~Derived() throw()    &#123;
        std::cout &lt;&lt; __TIME__ &lt;&lt; &quot;,&quot; &lt;&lt; __FUNCTION__ &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;;

int main() &#123;
    Derived d;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类NoCopyable的构造函数和析构函数因为是私有的，只有NoCopyable类的友元可以访问，Base类在继承时将模板的参数设置为了Base类，所以构造Base类对象时们可以直接访问父类（Base）的构造函数。</p>
<p>而创建Derived对象时，Derived类的构造函数就要负责虚基类（NoCopyable）的构造，但是NoCopyable的构造函数是私有的，Derived没有访问的权限（友元关系不能被继承的），所以Derived类在编译时就会报错。这样Base类就不能被继承了.</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树前中后序遍历</title>
    <url>/2019/10/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<ul>
<li>二叉树的前中后序是相对于<strong>根节点</strong>来说的</li>
<li>前根序遍历：先遍历根结点，然后遍历左子树，最后遍历右子树。<blockquote>
<p>ABDHECFG</p>
</blockquote>
</li>
<li>中根序遍历：先遍历左子树，然后遍历根结点，最后遍历右子树。<blockquote>
<p>HDBEAFCG</p>
</blockquote>
</li>
<li>后根序遍历：先遍历左子树，然后遍历右子树，最后遍历根节点。<blockquote>
<p>HDEBFGCA</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下：</p>
<ul>
<li>根据前根序序列的第一个元素建立根结点；</li>
<li>在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；</li>
<li>在前根序序列中确定左右子树的前根序序列；</li>
<li>由左子树的前根序序列和中根序序列建立左子树；</li>
<li>由右子树的前根序序列和中根序序列建立右子树。</li>
</ul>
</li>
<li><p>已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下：</p>
<ul>
<li>根据后根序序列的最后一个元素建立根结点；</li>
<li>在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；</li>
<li>在后根序序列中确定左右子树的后根序序列；</li>
<li>由左子树的后根序序列和中根序序列建立左子树；</li>
<li>由右子树的后根序序列和中根序序列建立右子树。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>大小端</title>
    <url>/2018/04/14/%E5%A4%A7%E5%B0%8F%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li><code>Little-Endian</code>:<code>低位字节排放在内存的低地址端，高位字节排放在内存的高地址端</code>。(逻辑上的低低高高)</li>
<li><code>Big-Endian</code>:<code>高位字节排放在内存的低地址端，低位字节排放在内存的高地址端</code>。(像数据流一样填充)</li>
<li>网络字节序：*TCP/IP各层协议将字节序定义为<code>Big-Endian</code>*，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</li>
</ul>
<h2 id="2-常见的CPU架构的字节序"><a href="#2-常见的CPU架构的字节序" class="headerlink" title="2. 常见的CPU架构的字节序"></a>2. 常见的CPU架构的字节序</h2><ul>
<li>Big Endian : PowerPC、IBM、Sun</li>
<li>Little Endian : x86、DEC</li>
<li>ARM : 大小端可选</li>
</ul>
<h2 id="3-判断方法"><a href="#3-判断方法" class="headerlink" title="3. 判断方法"></a>3. 判断方法</h2><p>大小端问题主要涉及的是<strong>非单字节非字符串外的其余数据</strong>的表示和传递，如short型、int型等。判断主机大小端的方法有很多，常见的是联合体判断法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">isBigEndian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>
        <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> num<span class="token punctuation">;</span>
    num<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>num<span class="token punctuation">.</span>b <span class="token operator">==</span> <span class="token number">0x12</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-转换方法"><a href="#4-转换方法" class="headerlink" title="4. 转换方法"></a>4. 转换方法</h2><p>出于效率考虑，大小端的处理在客户端。在客户端socket过来时把服务器主机的大小端通知给客户端，这样服务器就不需要改动，直接传递数据就行，这时候可以在客户端代码中封装几个宏，在客户端在收到数据后，根据那些宏来判断是否转换以及得出转换后的数值。<br>大小端转换最有效也是最常见的方法就是移位法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SWP16</span><span class="token expression"><span class="token punctuation">(</span>A<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint16<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span>    <span class="token operator">|</span> \  </span></span>
<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>uint16<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x00ff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> #define <span class="token function">__SWP32</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>uint32<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff000000</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> \
<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>uint32<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x00ff0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">|</span> \  
<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>uint32<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0000ff00</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">|</span> \  
<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>uint32<span class="token punctuation">)</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x000000ff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-为什么主机的字节序不统一"><a href="#5-为什么主机的字节序不统一" class="headerlink" title="5. 为什么主机的字节序不统一"></a>5. 为什么主机的字节序不统一</h2><p>这是因为 各个CPU厂商出于不同的逻辑考量，换句话说 大端和小端有其各自的优势。<br>我们知道计算机正常的内存增长方式是从低到高(当然栈不是)，取数据方式是从基址根据偏移找到他们的位置，从他们的存储方式可以看出，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。<br>而小端存储 第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效，也更符合我们手算的方式。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>安装deb和rpm文件</title>
    <url>/2018/04/14/%E5%AE%89%E8%A3%85deb%E5%92%8Crpm%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>deb 是 ubuntu 、debian 的格式。</li>
<li>rpm 是 redhat 、fedora 、suse 的格式。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装deb文件"><a href="#安装deb文件" class="headerlink" title="安装deb文件"></a>安装deb文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>安装包所在目录<span class="token operator">></span>
dpkg <span class="token parameter variable">-i</span> <span class="token operator">&lt;</span>安装包<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="安装rpm文件"><a href="#安装rpm文件" class="headerlink" title="安装rpm文件"></a>安装rpm文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>安装包所在目录<span class="token operator">></span>
<span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> <span class="token operator">&lt;</span>安装包<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟继承</title>
    <url>/2019/10/01/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<ul>
<li><p>概念：<br>C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。</p>
</li>
<li><p>解决问题：<br>解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>同义词：<br>虚基类（把一个动词当成一个名词而已）<br>当在多条继承路径上有一个公共的基类，在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)，若只想保存这个基类的一个实例，可以将这个公共基类说明为虚基类。</p>
</li>
<li><p>语法：</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class 派生类: virtual 基类1，virtual 基类2，...，virtual 基类n
&#123;
...&#x2F;&#x2F;派生类成员声明
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>执行顺序</p>
<ul>
<li>首先执行虚基类的构造函数，多个虚基类的构造函数按照被继承的顺序构造；</li>
<li>执行基类的构造函数，多个基类的构造函数按照被继承的顺序构造；</li>
<li>执行成员对象的构造函数，多个成员对象的构造函数按照申明的顺序构造；</li>
<li>执行派生类自己的构造函数；</li>
<li>析构以与构造相反的顺序执行；</li>
</ul>
<p>从虚基类直接或间接派生的派生类中的构造函数的成员初始化列表中都要列出对虚基类构造函数的调用。但只有用于建立对象的最派生类的构造函数调用虚基类的构造函数，而该派生类的所有基类中列出的对虚基类的构造函数的调用在执行中被忽略，从而保证对虚基类子对象只初始化一次。</p>
<p>在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。</p>
</li>
<li><p>因果：<br>多重继承-&gt;二义性-&gt;虚拟继承解决</p>
</li>
<li><p>通过输出的比较</p>
<blockquote>
<p>1.在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。<br>2.声明了虚基类之后，虚基类在进一步派生过程中始终和派生类一起，维护同一个基类子对象的拷贝。<br>3.观察类构造函数的构造顺序，拷贝也只有一份。</p>
</blockquote>
</li>
<li><p>与虚函数关系<br>虚拟继承与虚函数有一定相似的地方，但他们之间是绝对没有任何联系的。</p>
</li>
</ul>
<blockquote>
<p>再想一次：虚拟继承，虚基类，虚函数。</p>
</blockquote>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式的分类和原则</title>
    <url>/2019/10/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>设计模式(Design Pattern)是经过分类的、代码设计经验的总结, 是为了提高代码的可重用性、可理解性和可靠性, 是某类问题的解决方案, 代表了最佳实践.</p>
<p>面向对象的设计模式有七大基本原则：</p>
<ul>
<li>开闭原则(Open Closed Principle，OCP)</li>
<li>单一职责原则(Single Responsibility Principle, SRP)</li>
<li>里氏代换原则(Liskov Substitution Principle，LSP)</li>
<li>依赖倒转原则(Dependency Inversion Principle，DIP)</li>
<li>接口隔离原则(Interface Segregation Principle，ISP)</li>
<li>合成/聚合复用原则(Composite/Aggregate Reuse Principle，CARP)</li>
<li>最少知识原则(Least Knowledge Principle，LKP)或者迪米特法则(Law of Demeter，LOD)</li>
</ul>
<p>设计模式共有23种, 按类型分为三大类：</p>
<ul>
<li>创建型模式</li>
<li>结构型模式</li>
<li>行为型模式.</li>
</ul>
<span id="more"></span>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
<p><strong>其实还有两类：<em>并发型模式</em> 和 <em>线程池模式</em>。</strong></p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则就是说<code>对扩展开放，对修改关闭</code>。<br>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。<br>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏代换原则(Liskov Substitution Principle, LSP)面向对象设计的基本原则之一。</p>
<blockquote>
<p>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。</p>
</blockquote>
<p>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p>
<p>里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>这个是开闭原则的基础，具体内容：</p>
<blockquote>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
</blockquote>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>这个原则的意思是：</p>
<blockquote>
<p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口(多个接口方法集合到一个的接口)要好。</p>
</blockquote>
<h3 id="迪米特法则-最少知道原则"><a href="#迪米特法则-最少知道原则" class="headerlink" title="迪米特法则(最少知道原则)"></a>迪米特法则(最少知道原则)</h3><p>就是说：</p>
<blockquote>
<p>一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
</blockquote>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。<br>类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。<br>我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则是:</p>
<blockquote>
<p>尽量首先使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐</title>
    <url>/2019/10/04/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>关于C++字节对齐收集整理如下, 以便查阅.</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004，那它就是自然对齐的。</p>
<span id="more"></span>

<h2 id="为什么要字节对齐"><a href="#为什么要字节对齐" class="headerlink" title="为什么要字节对齐"></a>为什么要字节对齐</h2><p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，举个例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>运行时会报segment error，而在x86上就不会出现错误，只是效率下降。</p>
<h2 id="正确处理字节对齐"><a href="#正确处理字节对齐" class="headerlink" title="正确处理字节对齐"></a>正确处理字节对齐</h2><p>对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：</p>
<ul>
<li>数组  ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。</li>
<li>联合  ：按其包含的长度最大的数据类型对齐。</li>
<li>结构体：结构体中每个数据类型都要对齐。</li>
</ul>
<p>比如有如下一个结构体：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">stu</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">stu</span> my_stu<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于<code>在x86下，GCC默认按4字节对齐</code>，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为<code>20</code>，而不是15.</p>
<h2 id="attribute-选项"><a href="#attribute-选项" class="headerlink" title="__attribute__选项"></a>__attribute__选项</h2><p>我们可以按照自己设定的对齐大小来编译程序，GNU使用__attribute__选项来设置，比如我们想让刚才的结构按一字节对齐，我们可以这样定义结构体</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">stu</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　
<span class="token keyword">struct</span> <span class="token class-name">stu</span> my_stu<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>则sizeof(my_stu)可以得到大小为15。</p>
<p>上面的定义等同于</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">stu</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">stu</span> my_stu<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>__attribute__((packed))的变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐.</code></p>
<h2 id="什么时候需要设置对齐"><a href="#什么时候需要设置对齐" class="headerlink" title="什么时候需要设置对齐"></a>什么时候需要设置对齐</h2><p>在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.</p>
<h3 id="快速理解"><a href="#快速理解" class="headerlink" title="快速理解"></a>快速理解</h3><ol>
<li><p>什么是字节对齐？<br> 在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</p>
<p> 为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”。比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.</p>
</li>
<li><p>字节对齐有什么作用？<br> 字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。<br> 对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。</p>
</li>
<li><p>更改C编译器的缺省字节对齐方式<br> 在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p>
<ul>
<li>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。</li>
<li>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</li>
</ul>
</li>
</ol>
<p>  另外，还有如下的一种方式：<br>    - _<em>attribute</em><em>((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果  构中有成员的长度大于n，则按照最大成员的长度来对齐。<br>    - _<em>attribute</em></em> ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。<br>4. 举例说明<br>  <em>例1</em></p>
<pre><code><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">short</span> x2<span class="token punctuation">;</span>
    <span class="token keyword">float</span> x3<span class="token punctuation">;</span>
    <span class="token keyword">char</span> x4<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

由于编译器默认情况下会对这个struct作自然边界（有人说“自然对界”我觉得边界更顺口）对齐，结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，因此，编译器在x2和x1之间填充了一个空字节。结构的第三个成员x3和第四个成员x4恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，是该结构所有成员中要求的最大边界单元，因而test结构的自然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。

*例2*

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">//让编译器对这个结构作1字节对齐</span></span>
<span class="token keyword">struct</span> <span class="token class-name">test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">short</span> x2<span class="token punctuation">;</span>
    <span class="token keyword">float</span> x3<span class="token punctuation">;</span>
    <span class="token keyword">char</span> x4<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">//取消1字节对齐，恢复为默认4字节对齐</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

这时候sizeof(struct test)的值为8。

*例3*

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GNUC_PACKED</span> <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">PACKED</span> test  <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">short</span> x2<span class="token punctuation">;</span>
    <span class="token keyword">float</span> x3<span class="token punctuation">;</span>
    <span class="token keyword">char</span> x4<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>GNUC_PACKED<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

这时候sizeof(struct test)的值仍为8。
</code></pre>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><p>什么是字节对齐,为什么要对齐</p>
<blockquote>
<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
</blockquote>
<p>对齐的作用和原因</p>
<blockquote>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
</blockquote>
<h3 id="字节对齐对程序的影响"><a href="#字节对齐对程序的影响" class="headerlink" title="字节对齐对程序的影响"></a>字节对齐对程序的影响</h3><p>先让我们看几个例子吧(32bit,x86环境,gcc编译器):</p>
<p>设结构体如下定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在已知32位机器上各种数据类型的长度如下:</p>
<ul>
<li>char:   1(有符号无符号同)</li>
<li>short:  2(有符号无符号同)</li>
<li>int:    4(有符号无符号同)</li>
<li>long:   4(有符号无符号同)</li>
<li>float:  4</li>
<li>double: 8</li>
</ul>
<p>那么上面两个结构大小如何呢?</p>
<p>结果是:</p>
<ul>
<li>sizeof(strcut A)值为8</li>
<li>sizeof(struct B)的值却是12</li>
</ul>
<p>结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样;按理说A,B大小应该都是7字节。</p>
<p>之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果,那么我们是不是可以改变编译器的这种默认对齐设置呢,当然可以.例如:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> </span><span class="token comment">/*指定按2字节对齐*/</span></span>

<span class="token keyword">struct</span> <span class="token class-name">C</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">/*取消指定对齐，恢复缺省对齐*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>sizeof(struct C)值是8。</p>
<p>修改对齐值为1：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">/*指定按1字节对齐*/</span></span>

<span class="token keyword">struct</span> <span class="token class-name">D</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">/*取消指定对齐，恢复缺省对齐*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>sizeof(struct D)值为7。</p>
<p>后面我们再讲解#pragma pack()的作用.</p>
<h3 id="编译器对齐原则"><a href="#编译器对齐原则" class="headerlink" title="编译器对齐原则"></a>编译器对齐原则</h3><p>先让我们看四个重要的基本概念：</p>
<ol>
<li>数据类型自身的对齐值： 对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>指定对齐值：#pragma pack (value)时的指定对齐值value。</li>
<li><strong>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值</strong>。</li>
</ol>
<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。<strong>有效对齐值N是最终用来决定数据存放地址方式的值，最重要。</strong>有效对齐N，就是表示“对齐在N上”，也就是说该数据的”存放起始地址%N=0”.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是<code>结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍</code>，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>
<p>例子分析：</p>
<p>分析例子B；</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。<br><strong>第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1</strong>，所以其存放地址0x0000符合0x0000%1=0.<br>第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。<br>第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。</p>
<p>再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;</p>
<p>其实如果就这一个就来说它已将满足字节对齐了,因为它的起始地址是0,因此肯定是对齐的,之所以在后面补充2个字节,是因为编译器为了实现结构数组的存取效率,试想如果我们定义了一个结构B的数组,那么第一个结构起始地址是0没有问题,但是第二个结构呢?按照数组的定义,数组中所有元素都是紧挨着的,如果我们不把结构的大小补充为4的整数倍,那么下一个结构的起始地址将是0x0000A,这显然不能满足结构的地址对齐了,因此我们要把结构补充成有效对齐大小的整数倍.</p>
<p>其实诸如:对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的,只是因为这些类型的长度已知了,所以他们的自身对齐值也就已知了.</p>
<p>同理,分析上面例子C：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> </span><span class="token comment">/*指定按2字节对齐*/</span></span>
<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">/*取消指定对齐，恢复缺省对齐*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;<br>第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。<br>第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8.</p>
<h3 id="如何修改编译器的默认对齐值"><a href="#如何修改编译器的默认对齐值" class="headerlink" title="如何修改编译器的默认对齐值"></a>如何修改编译器的默认对齐值</h3><ol>
<li>在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</li>
<li>在编码时，可以这样动态修改：#pragma pack . <em><code>注意:是pragma而不是progma.</code></em></li>
</ol>
<h3 id="针对字节对齐-我们在编程中如何考虑"><a href="#针对字节对齐-我们在编程中如何考虑" class="headerlink" title="针对字节对齐,我们在编程中如何考虑"></a>针对字节对齐,我们在编程中如何考虑</h3><p>如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0,然后各个变量按照上面的原则进行排列即可,<strong>基本的原则就是把结构中的变量按照类型大小从小到大声明,尽量减少中间的填补空间.</strong><br>还有一种就是为了以空间换取时间的效率,我们显示的进行填补空间进行对齐,比如:<strong>有一种使用空间换时间做法是显式的插入reserved成员.</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> reserved<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//使用空间换时间</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>reserved成员对我们的程序没有什么意义,它只是起到填补空间以达到字节对齐的目的,当然即使不加这个成员通常编译器也会给我们自动填补对齐,我们自己加上它只是起到显式的提醒作用.</p>
<h3 id="字节对齐可能带来的隐患"><a href="#字节对齐可能带来的隐患" class="headerlink" title="字节对齐可能带来的隐患"></a>字节对齐可能带来的隐患</h3><p>代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
p<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span>

<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span>

p1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">*</span>p1<span class="token operator">=</span><span class="token number">0x0000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。</p>
<p>在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error,因为它们要求必须字节对齐.</p>
<h3 id="如何查找与字节对齐方面的问题"><a href="#如何查找与字节对齐方面的问题" class="headerlink" title="如何查找与字节对齐方面的问题"></a>如何查找与字节对齐方面的问题</h3><p>如果出现对齐或者赋值问题首先查看</p>
<ol>
<li>编译器的big little端设置</li>
<li>看这种体系本身是否支持非对齐访问</li>
<li>如果支持看设置了对齐与否,如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作</li>
</ol>
<p>举例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    <span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>  
        <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
        <span class="token keyword">short</span> c<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  

    <span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>  
        <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>  
        <span class="token keyword">short</span> c<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> </span><span class="token comment">/*指定按2字节对齐*/</span>  </span>
    <span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>  
        <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>  
        <span class="token keyword">short</span> c<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">/*取消指定对齐，恢复缺省对齐*/</span>  </span>

    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">/*指定按1字节对齐*/</span>  </span>
    <span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token punctuation">&#123;</span>  
        <span class="token keyword">char</span> b<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>  
        <span class="token keyword">short</span> c<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token comment">/*取消指定对齐，恢复缺省对齐*/</span>  </span>

    <span class="token keyword">int</span> s1<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> s2<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> s3<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> s4<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">8</span>
<span class="token number">12</span>
<span class="token number">8</span>
<span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
   <span class="token comment">// int a;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
   <span class="token comment">// int a;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">4</span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>输出都是4，说明之前的int影响对齐！</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>略探 Thrift</title>
    <url>/2025/05/03/get-to-know-thrift/</url>
    <content><![CDATA[<p>Thrift 作为 Apache 旗下的开源 RPC 框架，凭借其灵活的设计、强大的跨语言能力和高效的性能，在众多技术场景中发挥着重要作用。<br>本文将从核心概念、特性优势到实际应用几个方面略探 Thrift。</p>
<span id="more"></span>

<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>Thrift 是一个完整的 RPC 框架，它提供了一套完整的解决方案，涵盖接口定义语言（IDL）、编译器以及多种语言的库。Thrift 的核心在于通过 .thrift 文件来定义接口和数据结构，这种 IDL 语法简洁明了，开发者可以轻松定义服务接口、方法签名和数据类型。<br>Thrift 提供了多种编译器，支持多种编程语言，目前支持 C++、Java、Python、Go、JavaScript 等超过 20 种语言。通过编译生成的代码，开发者可以方便地在不同的语言环境中进行开发和调用。<br>从架构层面来看，Thrift 包含服务端和客户端两部分：服务端实现定义好的服务接口，对外提供服务；客户端则通过生成的代码调用服务端的方法，实现远程过程调用，整个过程简洁且高效。</p>
<h1 id="特性优势"><a href="#特性优势" class="headerlink" title="特性优势"></a>特性优势</h1><p>Thrift 具有以下几个突出的特性优势：</p>
<ul>
<li>高效的序列化和反序列化：Thrift 使用自己的二进制协议进行序列化和反序列化，能够高效地处理复杂的数据结构，减少数据传输的开销。</li>
<li>支持多种编程语言：Thrift 支持多种主流编程语言，开发者可以根据自己的需求选择合适的语言进行开发，提高开发效率。</li>
<li>支持双向流式通信：Thrift 支持双向流式通信，客户端和服务端可以同时发送和接收多个消息，适用于实时数据传输场景。</li>
<li>支持元数据和认证：Thrift 支持元数据和认证机制，开发者可以在请求和响应中添加自定义的元数据，实现身份验证和授权等功能。</li>
<li>支持负载均衡和故障转移：Thrift 内置了负载均衡和故障转移机制，能够自动处理服务端的负载均衡和故障转移，提高系统的可用性和稳定性。</li>
<li>支持多种传输协议：Thrift 支持多种传输协议，包括 HTTP、Binary、Compact、JSON 等，开发者可以根据自己的需求选择合适的协议进行通信。</li>
<li>易于集成：无论是新项目的搭建还是对旧系统的改造，都可以通过定义 .thrift 接口，快速实现服务间的通信。</li>
<li>扩展性良好：当系统需要增加新的服务或功能时，只需在 .thrift 文件中添加相应的接口定义，重新生成代码并实现业务逻辑即可。</li>
</ul>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>Thrift 在实际应用中具有广泛的应用场景，以下是一些常见的应用场景：</p>
<ul>
<li>微服务架构：Thrift 可以用于构建微服务架构，将不同的服务之间通过 Thrift 进行通信，实现服务的解耦和扩展。</li>
<li>分布式系统：Thrift 可以用于构建分布式系统，实现不同节点之间的远程过程调用，提高系统的可扩展性和性能。</li>
<li>实时数据传输：Thrift 支持双向流式通信，可以用于实时数据传输，如实时聊天、实时监控等场景。</li>
<li>跨语言调用：Thrift 支持多种编程语言，开发者可以根据自己的需求选择合适的语言进行开发，实现跨语言调用。</li>
<li>云原生应用：Thrift 可以用于构建云原生应用，实现服务的弹性扩展和快速部署，提高系统的可维护性和可扩展性。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Thrift 作为一款高效、灵活、可扩展的 RPC 框架，具有丰富的特性优势和广泛的应用场景。<br>无论是微服务架构、分布式系统还是实时数据传输等场景，Thrift 都能够提供高效、可靠的远程过程调用解决方案。<br>开发者可以根据自己的需求选择合适的语言和协议进行开发，实现跨语言调用和云原生应用。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
</search>
